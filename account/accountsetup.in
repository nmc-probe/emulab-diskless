#!/usr/bin/perl -w
#
# Copyright (c) 2010-2015 University of Utah and the Flux Group.
# 
# {{{GENIPUBLIC-LICENSE
# 
# GENI Public License
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and/or hardware specification (the "Work") to
# deal in the Work without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Work, and to permit persons to whom the Work
# is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Work.
# 
# THE WORK IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS
# IN THE WORK.
# 
# }}}
#
use strict;
use English;
use Getopt::Std;
use Data::Dumper;

#
# Setup accounts/projects/group stuff on ops/fs. This is installed on
# op/fs and invoked from boss by tbacct and the proj/group scripts.
#
sub usage()
{
    print "Usage: accountsetup adduser ...\n";
    print "       accountsetup deluser ...\n";
    print "       accountsetup moduser ...\n";
    print "       accountsetup addproject ...\n";
    print "       accountsetup addgroup ...\n";
    print "       accountsetup delproject ...\n";
    print "       accountsetup delgroup ...\n";
    exit(1);
}
my $optlist    = "dnf";
my $debug      = 0;
my $force      = 0;
my $impotent   = 0;

# XXX make this a sitevar
my $RENAMEDIRS = 1;

#
# Configure variables
#
my $TB		      = "@prefix@";
my $WITHZFS	      = @WITHZFS@;
my $ZFS_ROOT          = "@ZFS_ROOT@";
my $ZFS_QUOTA_USER    = "@ZFS_QUOTA_USER@";
my $ZFS_QUOTA_PROJECT = "@ZFS_QUOTA_PROJECT@";
my $ZFS_QUOTA_GROUP   = "@ZFS_QUOTA_GROUP@";
my $USERADD	      = "/usr/sbin/pw useradd";
my $USERDEL	      = "/usr/sbin/pw userdel";
my $USERMOD	      = "/usr/sbin/pw usermod";
my $GROUPADD          = "/usr/sbin/pw groupadd";
my $GROUPDEL          = "/usr/sbin/pw groupdel";
my $CHPASS	      = "/usr/bin/chpass";
my $CHOWN	      = "/usr/sbin/chown";
my $ZFS		      = "/sbin/zfs";
my $SKEL	      = "/usr/share/skel";
my $PIDFILE           = "/var/run/mountd.pid";

# XXX
my $NOSUCHUSER  = 67;
my $USEREXISTS  = 65;

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libtestbed;

# Generic (mounted) names for filesystems
my $USERROOT    = USERROOT();
my $PROJROOT    = PROJROOT();
my $GROUPROOT   = GROUPROOT();
my $SCRATCHROOT = SCRATCHROOT();

# XXX we need the real fs mountpoints too
my $FSUSERROOT    = "@FSDIR_USERS@";
my $FSPROJROOT    = "@FSDIR_PROJ@";
my $FSGROUPROOT   = "@FSDIR_GROUPS@";
my $FSSCRATCHROOT = "@FSDIR_SCRATCH@";

# Project subdir list
my @DIRLIST  = ("exp", "images", "logs", "deltas", "tarfiles", "rpms",
		"groups", "tiplogs", "images/sigs", "templates");
# Groups subdir list
my @GDIRLIST = ("exp", "images", "logs", "tarfiles", "rpms", "tiplogs");

#
# Function prototypes
#
sub AddUser();
sub DeleteUser();
sub ModifyUser();
sub AddProject();
sub AddGroup();
sub DelProject();
sub DelGroup();
sub fatal($);
sub ZFSexists($);
sub MakeDir($$);
sub WhackDir($$);
sub mysystem($);

#
# Check args.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"f"})) {
    $force = 1;
}
if (defined($options{"n"})) {
    $impotent = 1;
}
usage()
    if (@ARGV < 1);

my $cmd = shift(@ARGV);

#
# Now dispatch operation.
#
SWITCH: for ($cmd) {
    /^adduser$/ && do {
	AddUser();
	last SWITCH;
    };
    /^deluser$/ && do {
	DeleteUser();
	last SWITCH;
    };
    /^moduser$/ && do {
	ModifyUser();
	last SWITCH;
    };
    /^addproject$/ && do {
	AddProject();
	last SWITCH;
    };
    /^addgroup$/ && do {
	AddGroup();
	last SWITCH;
    };
    /^delproject$/ && do {
	DelProject();
	last SWITCH;
    };
    /^delgroup$/ && do {
	DelGroup();
	last SWITCH;
    };
    # Default
    usage();
}
exit(0);

#
# Usage: adduser username unix_uid full_name homedir unix_gid shell [ phash ]
#
sub AddUser()
{
    if (@ARGV < 6) {
	fatal("adduser: Wrong number of arguments");
    }
    
    my $user  = shift(@ARGV);
    my $uid   = shift(@ARGV);
    my $name  = shift(@ARGV);
    my $hdir  = shift(@ARGV);
    my $gid   = shift(@ARGV);
    my $shell = shift(@ARGV);
    my $hash  = (@ARGV ? shift(@ARGV) : undef);

    if (! -d "$hdir") {
	# XXX we only handle homedirs of the form /users/$user here...
	if ($hdir ne "$USERROOT/$user" || MakeDir($USERROOT, $user)) {
	    fatal("Could not create $user homedir $hdir");
	}
    }

    if (mysystem("egrep -q -s '^${user}:' /etc/passwd") &&
	mysystem("$USERADD $user -u $uid -c \"$name\" ".
	       "-k $SKEL -h - -d $hdir -g $gid -s $shell")) {
	if (($? >> 8) != $USEREXISTS) {
	    fatal("$USERADD: could not add account");
	}
    }

    #
    # Since we do not populate the new homedir with the useradd call,
    # we need to copy the skeleton files over.
    #
    if (! -e "$hdir/.cshrc") {
	opendir(DIR, "$SKEL") or
	    fatal("Unable to open skeleton directory");
	while (my $file = readdir(DIR)) {
	    if ($file =~ /^dot(.*)$/) {
		mysystem("/bin/cp -fp $SKEL/$file $hdir/$1") == 0
		    or fatal("Could not copy $SKEL/$file to $hdir/$1");
	    }
	}

	#
	# And set the owner and group right on everything
	#
	mysystem("/usr/sbin/chown -R $user:$gid $hdir") == 0
	    or fatal("Could not chown $hdir");
    }

    #
    # Finally, set any initial password hash
    #
    if (defined($hash) &&
	mysystem("$CHPASS -p '$hash' $user")) {
	fatal("Could not initialize password");
    }
    return 0;
}

#
# Usage: deluser username homedir
#
sub DeleteUser()
{
    if (@ARGV != 2) {
	fatal("deluser: Wrong number of arguments");
    }
    my $user  = shift(@ARGV);
    my $hdir  = shift(@ARGV);

    #
    # Note that this does NOT remove the user's homedir.
    # We remove/rename it below...
    #
    if (mysystem("$USERDEL $user")) {
	if (($? >> 8) != $NOSUCHUSER) {
	    fatal("Could not remove user $user");
	}
    }

    # XXX we only handle homedirs of the form /users/$user here...
    if ($hdir ne "$USERROOT/$user" || WhackDir($USERROOT, $user)) {
	fatal("Could not destroy $user homedir $hdir");
    }

    return 0;
}

#
# Usage: username group1 [ group2 ... groupN ]
# XXX this is specific to what is required by setgroups.
#
sub ModifyUser()
{
    if (@ARGV < 2) {
	fatal("moduser: Wrong number of arguments");
    }
    my $user  = shift(@ARGV);
    my $pgroup  = shift(@ARGV);
    my $grouplist = "''";
    if (@ARGV > 0) {
	$grouplist = "-G '" . join(',', @ARGV) . "'";
    }

    if (mysystem("$USERMOD $user -g $pgroup $grouplist")) {
	fatal("Could not modify user $user to add groups!\n");
    }

    #
    # Make sure the users dot files and other critical files/dirs
    # are in the correct group. I looked at the source code to
    # chown, and it does not do anything to files that are already
    # set correctly. Thank you chown.
    #
    my @dots = (".login", ".profile", ".cshrc", ".ssl", ".ssh");
    my $homedir = USERROOT() . "/$user";

    mysystem("$CHOWN $user:$pgroup $homedir") == 0
	or fatal("Could not chown home dir to $user:$pgroup");

    foreach my $dot (@dots) {
	if (-e "$homedir/$dot") {
	    mysystem("$CHOWN -R $user:$pgroup $homedir/$dot") == 0
		or fatal("Could not chown $homedir/$dot to $user:$pgroup");
	}
    }

    return 0;
}

#
# Usage: addproject projname unix_gname unix_gid unix_uid
#
sub AddProject()
{
    if (@ARGV != 4) {
	fatal("addproject: Wrong number of arguments");
    }
    my $name      = shift(@ARGV);
    my $unix_name = shift(@ARGV);
    my $unix_gid  = shift(@ARGV);
    my $unix_uid  = shift(@ARGV);

    # Create the project unix group
    if (mysystem("egrep -q -s '^${unix_name}:' /etc/group")) {
	print "Adding group $unix_name ...\n";

	if (mysystem("$GROUPADD $unix_name -g $unix_gid")) {
	    fatal("Could not add group $unix_name ($unix_gid)!\n");
	}
    }

    # Create the /proj directory
    my $path = "$PROJROOT/$name";
    if (! -d "$path" && MakeDir($PROJROOT, $name)) {
	fatal("Could not make directory '$path'");
    }
    if (! chmod(0770, "$path")) {
	fatal("Could not chmod '$path' to 0770: $!");
    }
    if (! chown($unix_uid, $unix_gid, "$path")) {
	fatal("Could not chown '$path' to $unix_uid/$unix_gid: $!");
    }

    # Create required /proj subdirs
    foreach my $dir (@DIRLIST) {
	$path = "$PROJROOT/$name/$dir";
	if (! -d "$path" && !mkdir("$path", 0770)) {
	    fatal("Could not make directory '$path': $!");
	}
	if (! chmod(0770, "$path")) {
	    fatal("Could not chmod '$path' to 0770: $!");
	}
	if (! chown($unix_uid, $unix_gid, "$path")) {
	    fatal("Could not chown '$path' to $unix_uid/$unix_gid: $!");
	}
    }

    # Create the /groups directory
    $path = "$GROUPROOT/$name";
    if (! -d "$path" && MakeDir($GROUPROOT, $name)) {
	fatal("Could not make directory '$path'");
    }
    if (! chmod(0770, "$path")) {
	fatal("Could not chmod '$path' to 0770: $!");
    }
    if (! chown($unix_uid, $unix_gid, "$path")) {
	fatal("Could not chown '$path'  to $unix_uid/$unix_gid: $!");
    }

    # Create a symlink for the default group
    $path = "$GROUPROOT/$name/$name";
    if (! -e "$path") {    
	if (mysystem("ln -s $PROJROOT/$name $path")) {
	    fatal("Could not symlink $PROJROOT/$name to $path");
	}
    }

    # Finally, create /scratch dir if supported
    if ($SCRATCHROOT) {
	$path = "$SCRATCHROOT/$name";
	if (! -d "$path" && MakeDir($SCRATCHROOT, $name)) {
	    fatal("Could not make directory '$path'");
	}
	if (! chmod(0770, "$path")) {
	    fatal("Could not chmod '$path' to 0770: $!");
	}
	if (! chown($unix_uid, $unix_gid, "$path")) {
	    fatal("Could not chown '$path'  to $unix_uid/$unix_gid: $!");
	}
    }

    return 0;
}

#
# Usage: addgroup groupname unix_gname unix_gid unix_uid projname
#
sub AddGroup()
{
    if (@ARGV != 5) {
	fatal("addgroup: Wrong number of arguments");
    }
    my $name      = shift(@ARGV);
    my $unix_name = shift(@ARGV);
    my $unix_gid  = shift(@ARGV);
    my $unix_uid  = shift(@ARGV);
    my $projname  = shift(@ARGV);

    # Create the group unix group
    if (mysystem("egrep -q -s '^${unix_name}:' /etc/group")) {
	print "Adding group $unix_name ...\n";

	if (mysystem("$GROUPADD $unix_name -g $unix_gid")) {
	    fatal("Could not add group $unix_name ($unix_gid)!\n");
	}
    }

    # Create the /groups/gid directory
    my $path = "$GROUPROOT/$projname/$name";
    # XXX note that this is always a regular directory, not a filesystem
    if (! -d "$path" && !mkdir("$path", 0770)) {
	fatal("Could not make directory '$path': $!");
    }
    if (! chmod(0770, "$path")) {
	fatal("Could not chmod '$path' to 0770: $!");
    }
    if (! chown($unix_uid, $unix_gid, "$path")) {
	fatal("Could not chown '$path' to $unix_uid/$unix_gid: $!");
    }

    # Create required /groups/gid subdirs
    foreach my $dir (@GDIRLIST) {
	$path = "$GROUPROOT/$projname/$name/$dir";
	if (! -d "$path" && !mkdir("$path", 0770)) {
	    fatal("Could not make directory '$path': $!");
	}
	if (! chmod(0770, "$path")) {
	    fatal("Could not chmod '$path' to 0770: $!");
	}
	if (! chown($unix_uid, $unix_gid, "$path")) {
	    fatal("Could not chown '$path' to $unix_uid/$unix_gid: $!");
	}
    }

    return 0;
}

#
# Usage: delproject projname unix_gname
#
sub DelProject()
{
    if (@ARGV != 2) {
	fatal("delproject: Wrong number of arguments");
    }
    my $name       = shift(@ARGV);
    my $unix_name  = shift(@ARGV);

    if ((-d "$PROJROOT/$name" && WhackDir($PROJROOT, $name)) ||
	(-d "$GROUPROOT/$name" && WhackDir($GROUPROOT, $name)) ||
	($SCRATCHROOT && -d "$SCRATCHROOT/$name" &&
	 WhackDir($SCRATCHROOT, $name))) {
	fatal("Could not destroy project '$name' related directories");
    }

    if (mysystem("egrep -q -s '^${unix_name}:' /etc/group") == 0) {
	print "Deleting project $unix_name ...\n";

	if (mysystem("$GROUPDEL $unix_name")) {
	    fatal("Could not delete group $unix_name!\n");
	}
    }
    return 0;
}

#
# Usage: delgroup groupname unix_gname projname
#
sub DelGroup()
{
    if (@ARGV != 3) {
	fatal("delgroup: Wrong number of arguments");
    }
    my $name      = shift(@ARGV);
    my $unix_name = shift(@ARGV);
    my $projname   = shift(@ARGV);

    #
    # XXX groups are different because they are a subdirectory under
    # /groups/<pid>/.
    #
    if (-d "$GROUPROOT/$projname/$name" &&
	WhackDir($GROUPROOT, "$projname/$name")) {
	fatal("Could not destroy project group '$name' related directories");
    }

    if (mysystem("egrep -q -s '^${unix_name}:' /etc/group") == 0) {
	print "Deleting group $unix_name ...\n";

	if (mysystem("$GROUPDEL $unix_name")) {
	    fatal("Could not delete group $unix_name!\n");
	}
    }
    return 0;
}

#
# Check for ZFS existence.
#
sub ZFSexists($)
{
    my ($path) = @_;

    mysystem("$ZFS list $path >/dev/null 2>&1");
    return ($? ? 0 : 1);
}

sub MakeDir($$)
{
    my ($fs,$dir) = @_;
    my ($cmd,$cmdarg,$path);

    # XXX right now we assume that WITHZFS means per-user/proj FSes
    if ($WITHZFS) {
	$cmd = "$ZFS create";
	$path = "${ZFS_ROOT}${fs}/$dir";

	# XXX quotas
	if ($fs eq $USERROOT) {
	    $cmdarg = "-o quota=$ZFS_QUOTA_USER";
	} elsif ($fs eq $PROJROOT) {
	    $cmdarg = "-o quota=$ZFS_QUOTA_PROJECT";
	} elsif ($fs eq $GROUPROOT) {
	    $cmdarg = "-o quota=$ZFS_QUOTA_GROUP";
	} else {
	    $cmdarg = "";
	}
    } else {
	$cmd = "mkdir";
	$cmdarg = "";
	$path = "$fs/$dir";
    }
    if (mysystem("$cmd $cmdarg $path")) {
	return $?;
    }

    # should we be setting permissions or ownership here?

    return 0;
}

sub WhackDir($$)
{
    my ($fs,$dir) = @_;
    my $zfsfs = "";

    if ($WITHZFS) {
	my $path = "${ZFS_ROOT}${fs}/$dir";
	$zfsfs = $path
	    if (ZFSexists($path));
    }
    if ($RENAMEDIRS) {
	my ($cmd, $path, $npath);
	my $suffix = "-D" . time();

	if ($zfsfs) {
	    $cmd = "$ZFS rename";
	    $path = $zfsfs;
	    $npath = "${ZFS_ROOT}${fs}/$dir$suffix";
	} else {
	    $cmd = "mv";
	    $path = "$fs/$dir";
	    $npath = "$fs/$dir$suffix";
	}
	if (mysystem("$cmd $path $npath")) {
	    return $?;
	}

	# Since we reuse uid/gids let's make the dir root/0700
	$path = "$fs/$dir$suffix";
	if (!chown(0, 0, $path) || !chmod(0700, $path)) {
	    print STDERR "WARNING: could not chown/chmod '$path'!\n";
	}
    }
    #
    # XXX maybe we should do this in the background since it could
    # take a really long time!
    #
    else {
	my ($cmd, $path);

	if ($zfsfs) {
	    $cmd = "$ZFS destroy -f";
	    $path = $zfsfs;
	} else {
	    $cmd = "rm -rf";
	    $path = "$fs/$dir";
	}
	if (mysystem("$cmd $path")) {
	    return $?;
	}
    }
    return 0;
}

#
# HUP Mountd after changes to ZFS volumes. Not used, Mike says we
# can do "zfs share -a" instead, but I will leave this code here
# for now.
#
sub HUPMountd()
{
    if (! -e $PIDFILE) {
	fatal("$PIDFILE does not exist. Is mountd running?");
    }
    my $daemonpid = `cat $PIDFILE`;
    chomp($daemonpid);
    # untaint
    if ($daemonpid =~ /^([-\@\w.]+)$/) {
	$daemonpid = $1;
    }
    if (kill('HUP', $daemonpid) == 0) {
	fatal("Could not kill(HUP) process $daemonpid (mountd): $!");
    }
    # Give mountd time to react.
    sleep(1);
}

# XXX temporary while debugging
sub mysystem($)
{
    my $cmd = shift;

    print STDERR "accountsetup: '$cmd'\n";

    if (open(FD, ">>/usr/testbed/log/accountsetup.log")) {
	my $tstamp = POSIX::strftime("%b %e %H:%M:%S", localtime());
	print FD "$tstamp: $cmd\n";
	close(FD);
    }
    return system($cmd);
}

sub fatal($) {
    my ($msg) = @_;

    print STDERR "$msg\n";
    exit(-1);
}
