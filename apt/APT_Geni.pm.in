#!/usr/bin/perl -wT
#
# Copyright (c) 2007-2016 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
package APT_Geni;

use strict;
use English;
use Data::Dumper;
use Carp;
use Exporter;
use vars qw(@ISA @EXPORT $AUTOLOAD);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use EmulabConstants;
use emdb;
use libtestbed;
use GeniCertificate;
use GeniCredential;

# Configure variables
my $TB		  = "@prefix@";
my $MAINSITE      = @TBMAINSITE@;
my $TBOPS         = "@TBOPSEMAIL@";
my $SACERT	  = "$TB/etc/genisa.pem";
my $EMCERT	  = "$TB/etc/emulab.pem";
my $EMKEY	  = "$TB/etc/emulab.key";

# Cache credentials so we do not keep regenerating down inside the
# libraries that make the XMLRPC calls.
my %credcache = ();

# Use real abac credentials (which means we can do speaks-for at ALS2).
my $USEABACCREDS  = 0;

#
# Generate the credentials we need. 
#
sub GenCredentials($$;$$)
{
    my ($target, $geniuser, $privs, $allowexpiredspeaksfor) = @_;
    my ($speaksfor, $credential, $oldexpires);
    # If the caller does not want a speaksfor, do not generate.
    my $wantspeaksfor = wantarray;

    my $speaker_signer = $GeniCredential::LOCALSA_FLAG;
    #
    # Utah; Guest users use the apt CA, and so we must sign the speaksfor
    # credential with the APT SA as well so that the target of the
    # speaksfor credential is in the same namespace as the signer.
    #
    if (!$geniuser->IsLocal() && $MAINSITE) {
	$speaker_signer = "/usr/testbed/etc/utah-apt.sa";
    }
    my $cachetag = $target->urn() . "::" . $geniuser->urn();
    
    #
    # If the target is a slice, and expired, change the expiration so
    # that the credential we generate is not also expired (and invalid).
    #
    if (ref($target) eq "GeniSlice" && $target->IsExpired()) {
	$oldexpires = $target->expires();
	$target->SetExpiration(time() + (24 * 3600));
	delete($credcache{$cachetag})
	    if (exists($credcache{$cachetag}));
    }
    #
    # Check cache.
    #
    if (exists($credcache{$cachetag})) {
	($credential,$speaksfor) = @{ $credcache{$cachetag} };
	goto cached;
    }

    #
    # If a local user account, but a nonlocal id, then we should
    # have a speaksfor credential stored, as well as a certificate
    # for the user.
    #
    if ($geniuser->IsLocal() && $geniuser->emulab_user()->IsNonLocal()) {
	my ($speaksfor_string, $certificate_string) =
	    $geniuser->emulab_user()->GetStoredCredential();
	if (! (defined($speaksfor_string) &&
	       defined($certificate_string))) {
	    print STDERR "No stored speaksfor/certificate for $geniuser\n";
	    goto bad;
	}
	if ($wantspeaksfor) {
	    $speaksfor = GeniCredential->CreateFromSigned($speaksfor_string, 1);
	    if (!defined($speaksfor)) {
		print STDERR "Could not create speaksfor credential\n";
		goto bad;
	    }
	}
	#
	# Ick, if the speaks for credential has expired, we cannot
	# operate as the user. We have no choice but to throw away
	# these credentials and generate a new one issued to the local
	# SA instead of the user and not bother with a speaksfor.
	#
	if ($speaksfor->IsExpired()) {
	    print STDERR "speaksfor credential for $geniuser has expired\n";
	    goto bad
		if (!$allowexpiredspeaksfor);

	    # Be careful not to return this.
	    $speaksfor = undef;
	    
	    print STDERR "-> Generating an SA credential instead\n";
	    $credential = APT_Geni::GenAuthCredential($target, $privs);
	    if (!defined($credential)) {
		print STDERR "-> Could not generate SA credential!\n";
		goto bad;
	    }
	    goto cached;
	}
	my $certificate =
	    GeniCertificate->LoadFromString($certificate_string);
	if (!defined($certificate)) {
	    print STDERR "Could not load certificate from string\n";
	    goto bad;
	}
	$credential = GeniCredential->Create($target, $certificate);
    }
    else {
	if ($wantspeaksfor) {
	    #
	    # The Utah SA is always the speaker, even if the user is a guest
	    # with the alternate CA.
	    #
	    my $sa_certificate = GeniCertificate->LoadFromFile($SACERT);
	    if (!defined($sa_certificate)) {
		print STDERR "Could not load certificate from $SACERT\n";
		goto bad;
	    }
	    my $sa_authority = GeniAuthority->Lookup($sa_certificate->urn());
	    if (!defined($sa_authority)) {
		prnt STDERR "Could not load SA authority object\n";
		goto bad;
	    }

	    if ($USEABACCREDS) {
		$speaksfor = GenABACCredential($geniuser, $sa_authority);
		goto bad
		    if (!defined($speaksfor));
	    }
	    else {
		$speaksfor = GeniCredential->Create($geniuser, $sa_authority);
		if (!defined($speaksfor)) {
		    print STDERR "Could not create speaksfor credential\n";
		    goto bad;
		}
		$speaksfor->SetType("speaksfor");
		if ($speaksfor->Sign($speaker_signer)) {
		    print STDERR "Could not sign speaksfor credential\n";
		    goto bad;
		}
	    }
	}
	$credential = GeniCredential->Create($target, $geniuser);
    }
    if (!defined($credential)) {
	print STDERR "Could not create credential for $target\n";
	goto bad;
    }
    # Add optional privs.
    if (defined($privs)) {
	foreach my $priv (@{ $privs }) {
	    $credential->AddCapability($priv, 0);
	}
    }
    # And sign it.
    if ($credential->Sign($GeniCredential::LOCALSA_FLAG) != 0) {
	$credential->Delete();
	print STDERR "Could not sign $target credential\n";
	goto bad;
    }
    if ($wantspeaksfor) {
	$credcache{$cachetag} = [$credential, $speaksfor];
    }
  cached:
    $target->SetExpiration($oldexpires)
	if (defined($oldexpires));
    if (wantarray) {
	return ($credential, $speaksfor);
    }
    return $credential;
  bad:
    $target->SetExpiration($oldexpires)
	if (defined($oldexpires));
    return ();
}

#
# Return the authority object for a URN.
#
sub GetAuthority($)
{
    my ($urn) = @_;

    my $cm_authority = GeniAuthority->Lookup($urn);
    if (!defined($cm_authority)) {
	$cm_authority = GeniAuthority->CreateFromRegistry("cm", $urn);
	if (!defined($cm_authority)) {
	    print STDERR "Could not load CM authority object\n";
	    return undef;
	}
    }
    return $cm_authority;
}

#
# Load the context operate as; always the same for APT.
#
sub GeniContext()
{
    my $certificate = GeniCertificate->LoadFromFile($SACERT);
    if (!defined($certificate)) {
	print STDERR "Could not load certificate from $SACERT\n";
	return undef;
    }
    return Genixmlrpc->Context($certificate);
}

sub RootContext()
{
    return Genixmlrpc->Context($EMCERT, $EMKEY);
}

#
# Generate an SA credential (sorta like an admin credential).
#
sub GenAuthCredential($;$)
{
    my ($target, $privs) = @_;
    my $oldexpires;

    my $owner = GeniCertificate->LoadFromFile($SACERT);
    if (!defined($owner)) {
	print STDERR "Could not load certificate from $SACERT\n";
	return undef;
    }
    #
    # If the target is a slice, and expired, change the expiration so
    # that the credential we generate is not also expired (and invalid).
    #
    if (ref($target) eq "GeniSlice" && $target->IsExpired()) {
	$oldexpires = $target->expires();
	$target->SetExpiration(time() + 600);
    }
    my $credential = GeniCredential->Create($target, $owner);
    if (!defined($credential)) {
	print STDERR "Could not create credential for $target\n";
	goto bad;
    }
    # Add optional privs.
    if (defined($privs)) {
	foreach my $priv (@{ $privs }) {
	    $credential->AddCapability($priv, 0);
	}
    }
    # And sign it.
    if ($credential->Sign($GeniCredential::LOCALSA_FLAG) != 0) {
	$credential->Delete();
	print STDERR "Could not sign $target credential\n";
	goto bad;
    }
    $target->SetExpiration($oldexpires)
	if (defined($oldexpires));
    return $credential;
  bad:
    $target->SetExpiration($oldexpires)
	if (defined($oldexpires));
    return undef;
}

#
# Generate a real ABAC credential
#
sub GenABACCredential($$)
{
    my ($geniuser, $speaker) = @_;
    require ABAC;
    import ABAC;

    my $userfile = $geniuser->GetCertificate()->WriteToFile(1);
    if (!defined($userfile)) {
	print STDERR "Could not write user cert/key to file!\n";
	return undef;
    }
    my $speakerfile = $speaker->GetCertificate()->WriteToFile(1);
    if (!defined($speakerfile)) {
	print STDERR "Could not write speaker cert/key to file!\n";
	return undef;
    }
    my $abacuser = ABAC::ID->new($userfile);
    if (!defined($abacuser)) {
	print STDERR "Could not create user ABAC:ID for $geniuser\n";
	return undef;
    }
    $abacuser->load_privkey($userfile);

    my $abactool = ABAC::ID->new($speakerfile);
    if (!defined($abactool)) {
	print STDERR "Could not create speaker ABAC:ID\n";
	return undef;
    }

    my $abacattr = ABAC::Attribute->new($abacuser,
					"speaks_for_" . $abacuser->keyid(),
					30 * 24 * 60 * 60);
    if (!defined($abacattr)) {
	print STDERR "Could not create ABAC::Attribute\n";
	return undef;
    }
    
    $abacattr->principal($abactool->keyid());
    $abacattr->bake();
    my $xml  = $abacattr->cert_chunk();
    my $cred = GeniCredential->CreateFromSigned($xml);
    if (!defined($cred)) {
	print STDERR "Could not create ABAC credential from $xml\n";
	return undef;
    }
    $cred->SetTargetCert($geniuser->GetCertificate());
    $cred->SetOwnerCert($speaker->GetCertificate());
    return $cred;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
