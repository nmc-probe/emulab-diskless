#!/usr/bin/perl -w

#
# Copyright (c) 2016 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#

use strict;
use English;
use POSIX ":sys_wait_h";
use Getopt::Std;
use Data::Dumper;
use File::Basename;

use libjsonrpc;
use EmulabConstants;
use Image;
use User;

# Func prototypes
sub cmd_loadimage($@);
sub cmd_reboot($;@);
sub GetSSHPipe();
sub chldhandler($);
sub genhandler($);
sub cleanexit($);
sub mysystem($);

# AUTOCONF variables
#my $TB = "@prefix@";

# Global variables
my $SSHPIPE;
my $CHWAITTMO = 10;
my $TBADB_PROXYCMD = "cd ~kwebb/git/emulab-devel/mobile && ./tbadb_proxy 2> /tmp/tbadb_proxy.log";
my $TBADB_HELLO_TMO      = 10;
my $TBADB_CHECKIMAGE_TMO = 30;
my $TBADB_LOADIMAGE_TMO  = 120;
my $TBADB_REBOOT_TMO     = 60;
my $SCP = "/usr/bin/scp";
my $SSHTB = "$TB/bin/sshtb";
my @SSH_ARGS = ('-o','BatchMode=yes','-o','StrictHostKeyChecking=no',
		'-o','ConnectTimeout=10');

my %DISPATCH = (
    'loadimage' => \&cmd_loadimage,
    'reboot'    => \&cmd_reboot,
);

sub showhelp() {
    print "Usage: $0 <rhost> <cmd> <args>\n\n";
    print "<rhost>: Remote host to run on (hosts adb-controlled devices)\n".
	  "<cmd>:   TBADB command to run (see list below).\n".
	  "<args>:  set of arguments specific to <cmd>\n";
    print "Command list: ". join(", ", keys %DISPATCH) ."\n";
}

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# We don't want to run this script unless it's the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be setuid! Maybe it's a development version?\n");
}

#
# Verify user and get user's DB uid and other info for later.
#
my $this_user = User->ThisUser();
if (! defined($this_user)) {
    die("You ($UID) do not exist!\n");
}


my %opts = ();
if (!getopts("dh",\%opts) || $opts{'h'} || @ARGV < 2) {
    showhelp();
    exit 1;
}

my ($RHOST, $CMD, @ARGS) = @ARGV;

my $debug = $opts{'d'} ? 1 : 0;

$libjsonrpc::debug = 1 if $debug;

die "tbadb: unknown command: $CMD\n"
    if (!exists($DISPATCH{$CMD}));

# Setup stuff for the SSH Pipe.
$SIG{CHLD} = \&chldhandler;
$SIG{HUP} = $SIG{TERM} = $SIG{INT} = \&genhandler;
$SSHPIPE = TBADB::SSHPipe->New($RHOST, $TBADB_PROXYCMD);

exit $DISPATCH{$CMD}->($RHOST, @ARGS);


#
# Given a valid image identifier (name, osid), project (to scope
# image) and node_id, load an image onto a remote device.  Check with
# the remote side to ensure the image is there, and tranfer it first
# if necessary.  The remote end keeps an LRU cache of images.
#
sub cmd_loadimage($@) {
    my ($rhost, $imagepid, $imagename, $node_id) = @_;

    # Argument checks.
    die "tbadb::cmd_loadimage: missing one or more arguments (need: <project> <image_name> <node_id>)!\n"
	if (!$rhost || !$imagepid || !$imagename || !$node_id);

    # Lookup image and extract some info.
    my $image = Image->Lookup($imagepid, $imagename);
    die "tbadb::cmd_loadimage: No such image descriptor $imagename in project $imagepid!\n"
	if (!defined($image));
    my $imageid = $image->imageid();
    my $imagepath = $image->path();
    $imagename  = $image->imagename(); # strip any version

    # Check user's access to the image.
    die "tbadb::cmd_loadimage: You do not have permission to use imageid $imageid!\n"
	if (!$this_user->IsAdmin() &&
	    !$image->AccessCheck($this_user, TB_IMAGEID_ACCESS));
    die "tbadb::cmd_loadimage: Cannot access image file: $imagepath\n"
	if (!-r $imagepath);

    # Make sure user has access to requested node too.
    my $node = Node->Lookup($node_id);
    die "tbadb::cmd_loadimage: Invalid node name $node_id!\n"
	if (!defined($node));
    die("tbadb::cmd_loadimage: You do not have permission to load an image onto $node\n")
	if (!$node->AccessCheck($this_user, TB_NODEACCESS_LOADIMAGE));

    # Get stats from the image file.
    my @fstats = stat($imagepath);
    my $mtime = $fstats[9];
    my $size  = $fstats[7];

    # Grab the RPC pipe.
    my ($chin, $chout) = GetPipe();
    die "tbadb::cmd_loadimage: Failed to get valid SSH pipe filehandles!\n"
	if (!$chin || !$chout);

    # Have remote side check for this image in its cache.
    die "tbadb::cmd_loadimage: Failed to send 'checkimage' RPC!\n"
	if (!SendRPCData($chout, 
			 EncodeCall("checkimage",
				    {
					IMG_PROJ => $imgpid,
					IMG_NAME => $imagename,
					IMG_TIME => $mtime,
					IMG_SIZE => $size,
				    })));
    my $pdu;
    die "tbadb::cmd_loadimage: Failed to receive valid response for 'checkimage'\n"
	if (RecvRPCData($chin, \$pdu, $TBADB_CHECKIMAGE_TMO) != 1);
    my $data = DecodeRPCData($pdu);
    die "tbadb::cmd_loadimage: Could not decode RPC response from 'checkimage'"
	if (!$data);
    if (exists($data->{ERROR})) {
	warn "tbadb::cmd_loadimage: Received error from 'checkimage':\n";
	warn "". Dumper($data);
	exit 1;
    }

    # Transfer the image to the remote host if necessary (SCP).
    if ($data->{RESULT}->{NEED_IMG} == 1) {
	print "tbadb: Sending $imagepath to $rhost\n";
	my $rpath = $data->{RESULT}->{REMOTE_PATH};
	die "tbadb::cmd_loadimage: Failed to transfer image to $rhost: $imagepath\n"
	    if (mysystem("$SCP -q -B -p $imagepath $rhost:$rpath") != 0);
    }

    # Now that the image is (ostensibly) in place on the remote side,
    # ask the remote host to load it onto the device.
    die "tbadb::cmd_loadimage: Failed to send 'loadimage' RPC!\n"
	if (!SendRPCData($chout, 
			 EncodeCall("loadimage",
				    {
					IMG_PROJ => $imgpid,
					IMG_NAME => $imgname,
					NODE_ID  => $node_id,
				    })));
    die "tbadb::cmd_loadimage: Failed to receive response for 'loadimage'\n"
	if (RecvRPCData($chin, \$pdu, $TBADB_LOADIMAGE_TMO) != 1);
    $data = DecodeRPCData($pdu);
    die "tbadb::cmd_loadimage: Could not decode RPC response from 'loadimage'\n"
	if (!$data);
    if (exists($data->{ERROR}) || !exists($data->{RESULT}->{SUCCESS})) {
	warn "tbadb::cmd_loadimage: Received error from 'loadimage':\n";
	warn "". Dumper($data);
	exit 1;
    }

    # Done!
    print "tbadb: Successfully loaded $imagepath to $node_id\n";
    exit 0;
}


sub cmd_reboot($;@) {
    my ($rhost, $node_id) = @_;

    die "tbadb::cmd_reboot: node_id or rhost arguments missing!\n"
	if (!$rhost || !$node_id);

    # Make sure user has access to requested node
    my $node = Node->Lookup($node_id);
    die "tbadb::cmd_reboot: Invalid node name $node_id!\n"
	if (!defined($node));
    die("tbadb::cmd_reboot: You do not have permission to reboot $node\n")
	if (!$node->AccessCheck($this_user, TB_NODEACCESS_REBOOT));

    my ($chin, $chout) = GetPipe();
    die "tbadb::cmd_reboot: Failed to get valid SSH pipe filehandles!\n"
	if (!$chin || !$chout);

    die "tbadb::cmd_reboot: Failed to send 'reboot' RPC!\n"
	if (!SendRPCData($chout, 
			 EncodeCall("reboot", { NODE_ID => $node_id })));

    my $pdu;
    die "tbadb::cmd_reboot: Failed to receive valid response for 'reboot'\n"
	if (RecvRPCData($chin, \$pdu, $TBADB_REBOOT_TMO) != 1);

    my $data = DecodeRPCData($pdu);
    die "tbadb::cmd_loadimage: Could not decode RPC response from 'reboot'"
	if (!$data);

    if (exists($data->{ERROR}) || !exists($data->{RESULT}->{SUCCESS})) {
	warn "tbadb::cmd_loadimage: Received error from 'reboot':\n";
	warn "". Dumper($data);
	exit 1;
    }
    
    print "tbadb: Successfully rebooted $node_id\n";
    exit 0;
}

sub GetPipe() {
    my ($chin, $chout);

    if (!$SSHPIPE->isopen()) {
	my $pdu;
	($chin, $chout) = $SSHPIPE->GetPipe();
	my $res = RecvRPCData($chin, \$pdu, $TBADB_HELLO_TMO);
	if ($res == -1) {
	    die "tbadb: Timeout while opening SSH Pipe!\n";
	}
	elsif ($res == 0) {
	    die "tbadb: Error encountered while opening SSH Pipe!\n";
	}
	my $hello = DecodeRPCData($pdu);
	die "tbadb: Unexpected data received when opening SSH Pipe!\n"
	    if (!$hello);
	die "tbadb: Did not receive valid 'hello' from remote end!\n"
	    if (!exists($hello->{RESULT}->{HELLO}));
    }

    return ($chin, $chout);
}

sub cleanexit($) {
    my $exval = shift;

    if ($SSHPIPE && $SSHPIPE->child()) {
	warn "tbadb: Killing SSH pipe process\n";
	$SIG{CHLD} = "IGNORE";
	my $stime = time();
	while (1) {
	    kill("TERM", $SSHPIPE->child());
	    select(undef,undef,undef,0.25); # Sleep for a quarter of a second.
	    my $pid = waitpid($SSHPIPE->child(), WNOHANG);
	    last
		if ($pid == $SSHPIPE->child() || $pid < 0);
	    if (time() - $stime > $CHWAITTMO) {
		warn "tbadb: Timed out waiting for SSH pipe child to exit!\n";
		last;
	    }
	    sleep 1;
	}
	$SSHPIPE = undef;
    }

    exit $exval;
}

sub chldhandler($) {
    my $pid = wait();
    if (!$SSHPIPE || $pid != $SSHPIPE->child()) {
	warn "tbadb: SIGCHLD handler: wait() did not return our child's PID!\n";
    } else {
	print "tbadb: SSH Pipe exited...\n";
	$SSHPIPE = undef;
    }
}

sub genhandler($) {
    cleanexit(1);
}

sub mysystem($) {
    my ($cmd) = @_;

    local $SIG{CHLD} = 'DEFAULT';
    return system($cmd);
}

END {
    cleanexit($?) if $SSHPIPE;
}

#
# SSHPipe session class
#
package TBADB::SSHPipe;

use IPC::Open2;

sub New($$$) {
    my ($class, $rhost, $rcmd) = @_;

    my $self = {};
    $self->{RHOST} = $rhost;
    $self->{RCMD}  = $rcmd;
    $self->{CHIN}  = undef;
    $self->{CHOUT} = undef;
    $self->{CHILD} = 0;
    bless($self, $class);

    return $self;
}

sub DESTROY($) {
    my $self = shift;
    $self->{CHIN}  = undef;
    $self->{CHOUT} = undef;
    $self->{CHILD} = 0;
}

sub child($)  { return $_[0]->{CHILD}; }

sub isopen($) {
    my ($self) = @_;
    my $isopen = 0;

    if ($self->{CHILD}) {
	if (kill("ZERO", $self->{CHILD})) {
	    $isopen = 1;
	} else {
	    $self->{CHILD} = undef;
	    $self->{CHIN}  = undef;
	    $self->{CHOUT} = undef;
	}
    }

    return $isopen;
}

sub GetPipe($) {
    my ($self) = @_;
    my ($chin, $chout);

    if (!$self->{CHILD}) {
	my $chpid = open2($chin, $chout, $SSHTB, @SSH_ARGS,
			  "-host", $self->{RHOST}, $self->{RCMD});
	if ($chpid < 1) {
	    warn "TBADB: Failed to open SSH pipe process!\n";
	}

	$self->{CHILD} = $chpid;
	$self->{CHIN}  = $chin;
	$self->{CHOUT} = $chout;
    }

    return ($self->{CHIN}, $self->{CHOUT});
}
