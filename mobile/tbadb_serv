#!/usr/bin/perl -wT

#
# Copyright (c) 2016 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
package TBADB::Server;

use strict;
use English;
use DB_File;
use IO::Socket::INET;
use base qw(Net::Server::Fork);

# Drag in Emulab clientside path stuff.
BEGIN { require "/etc/emulab/paths.pm"; import emulabpaths; }

use libtestbed;
use libtmcc qw(tmccbossinfo);
use libjsonrpc;
use tbadb_rpc;

# Function prototypes for non-object procedures.
sub rpc_checkimage($);
sub rpc_loadimage($);
sub rpc_captureimage($);
sub rpc_reboot($);
sub rpc_forward($);
sub rpc_unforward($);
sub rpc_nodewait($);
sub rpc_ping($);
sub rpc_exit($);
sub send_error($$$);
sub do_lru_cleanup();
sub unpack_bundle($$);
sub enter_fastboot($);
sub load_android_image($$$);
sub reboot_android($);
sub wait_for_android($);
sub setup_android_forward($$;$$);
sub remove_android_forward($;$);
sub check_adb();

# RPC function dispatch table
my %DISPATCH = (
    'checkimage'   => \&rpc_checkimage,
    'loadimage'    => \&rpc_loadimage,
    'captureimage' => \&rpc_captureimage,
    'reboot'       => \&rpc_reboot,
    'forward'      => \&rpc_forward,
    'unforward'    => \&rpc_unforward,
    'nodewait'     => \&rpc_nodewait,
    'ping'         => \&rpc_ping,
    'exit'         => \&rpc_exit,
);

# Constants
my $DEF_LOGLEVEL = 2;
my $PIDFILE = "/var/run/tbadb_serv.pid";
my $LOGFILE = "$LOGDIR/tbadb_serv.log";
my $MAPFILE = "$ETCDIR/tbadbmap";
my $FWDDBFILE = "$BOOTDIR/tbadbfwd.db";
my $ADB = "/usr/bin/adb";
my $FASTBOOT = "/usr/bin/fastboot";
my $TOUCH = "/usr/bin/touch";
my $IPTABLES = "/sbin/iptables";
my $HOST = "/usr/bin/host";
my $FILE = "/usr/bin/file";
my $RM = "/bin/rm";
my $UNZIP = "/usr/bin/unzip";
my $PS = "/bin/ps";
my $GREP = "/bin/grep";
my $IMAGE_CACHE = "/z/tbadb_img_cache";
my $WM_HIGH = 50 * 1000 * 1000 * 1000;  # 50 GB
my $WM_LOW  = 40 * 1000 * 1000 * 1000;  # 40 GB
my $MINPORT = 8001;
my $MAXPORT = 8100;
my $HOUSEKEEPING_INTERVAL = 60;
my $FASTBOOT_TMO = 15;
my $ANDROID_BOOT_TMO = 90;
my $IMGLOCK_TMO = 300;
my $LRULOCK_TMO = 60;
my $UNPACKLOCK_TMO = 30;
my $FWDLOCK_TMO = 30;

# Global variables
my %NMAP = ();
my %FWDPORTS = ();
my $RPCIN;
my $RPCOUT;
my $g_imglock;
my $debug = 0;

# Invoke the parent Net::Server class' run routine.
TBADB::Server->run({
    port       => TBADB_PORT,
    log_file   => $LOGFILE,
    log_level  => $DEF_LOGLEVEL,
    ipv        => 4,
    pid_file   => $PIDFILE,
    user       => "root",
    group      => "root",
    background => 1,
    setsid     => 1,
    no_client_stdout => 1,
    max_dequeue => 1,
    check_for_dequeue => $HOUSEKEEPING_INTERVAL,
});

##############################################################################
#
# Our Net::Server subclass override methods follow
#

#
# Add custom options to Net::Server object
#
sub options($$) {
    my ($self, $template) = @_;
    my $prop = $self->{'server'};

    # Let parent class setup its options.
    $self->SUPER::options($template);

    $prop->{'debug'} ||= undef;
    $template->{'debug'} = \ $prop->{'debug'};
}

#
# Do some overriding of config variables when debugging is requested
#
sub post_configure {
    my $self = shift;
    my $prop = $self->{'server'};

    # Don't go into the background if debugging was requested.  
    # Increase log level.
    if ($prop->{'debug'}) {
	warn "tbadb_serv: debug mode requested.  Staying in foreground.\n";
	$debug = $prop->{'debug'};  # XXX global var for non-OO funcs.
	$prop->{'background'} = 0;
	$prop->{'setsid'} = 0;
	$prop->{'log_level'} = 4;
	$prop->{'log_file'} = undef;
    }

    $self->SUPER::post_configure(@_);
}

#
# Do a bit of post-processing/checking after internal Net::Server
# configuration stage (which includes going into the background,
# setting up logging, etc.)
#
sub post_configure_hook($) {
    my $self = shift;
    my $prop = $self->{'server'};

    # Get IP for boss server and add it to the allowed list.
    my (undef, $bossip) = tmccbossinfo();
    die "tbadb_serv: Could not get IP address for boss server!\n"
	if (!$bossip || $bossip !~ /^(\d+\.\d+\.\d+\.\d+)$/);
    push @{$prop->{'cidr_allow'}}, "${1}/32";

    # Only allow root to run the script.
    die("tbadb_serv: May only be run as root!\n")
	if ($UID != 0);

    # Read in the node_id -> serial number map (used by non-OO funcs).
    die "tbadb_serv: Cannot run without serial number mapping file: $MAPFILE\n"
	if (!-r $MAPFILE);
    open(MFILE, "<$MAPFILE")
	or die "tbadb_serv: Can't open map file: $MAPFILE: $!\n";
    while (my $ln = <MFILE>) {
	chomp $ln;
	next if (!$ln || $ln =~ /^\s*#.*$/);
	if ($ln !~ /^\s*([-\w]+)\s+([a-zA-Z0-9]+)\s*$/) {
	    warn "tbadb_serv: malformed node mapping line: $ln\n";
	    next;
	}
	$NMAP{$1} = $2;
	$NMAP{$2} = $1;
    }
    close(MFILE);

    # Check/fix adb server and forwarding rules.
    die "tbadb_serv: Startup checks failed!\n"
	if !check_adb();
}

#
# Connection data handler called in the child worker processes forked by
# the parent Net::Server::Fork process.
#
sub process_request($) {
    my $self = shift;

    # Setup the RPC handles;
    $RPCIN  = $self->{'server'}->{'client'};
    $RPCOUT = $RPCIN;

    # Send "hello" To let remote end know we are ready.
    die "tbadb_serv: Could not send hello to caller. Terminating connection.\n"
	if !SendRPCData($RPCOUT, EncodeResult(-1, { HELLO => 1 }));

    while (1) {
	# Get PDU
	my $pdu;
	my $rcode = RecvRPCData($RPCIN, \$pdu);
	if ($rcode == -1) {
	    warn "tbadb_serv: timed out waiting for RPC data. Terminating connection\n";
	    exit 1;
	}
	elsif ($rcode == 0) {
	    warn "tbadb_serv: EOF from RPC pipe. Terminating connection\n";
	    exit 1;
	}
    
	# Decode PDU
	my $data = DecodeRPCData($pdu);
	if (!$data) {
	    warn "tbadb_serv: unable to decode RPC data. Terminating connection.\n";
	    exit 1;
	}

	# Dispatch function calls
	my $func = $data->{FUNCTION};
	if (defined($func)) {
	    if (!exists($DISPATCH{$func})) {
		warn "tbadb_serv: Unkown RPC: $func. Sending error and terminating connection.\n";
		send_error($data->{FID}, RPCERR_BADFUNC, "Unknown function: $func");
		exit 1;
	    }
	    $DISPATCH{$func}->($data);
	} else {
	    warn "tbadb_serv: Received RPC data that was not a function call. Terminating connection.\n";
	    exit 1;
	}
    }
}

#
# Periodically do housekeeping tasks.  This includes babysitting the
# adb forwarding setup (ensuring persistence).
#
sub run_dequeue($) {
    my $self = shift;

    warn "tbadb_serv: ADB server check failed!\n"
	if (!check_adb());
}

##############################################################################
#
# RPC dispatch functions follow.
#

sub rpc_checkimage($) {
    my ($data) = @_;
    my $proj    = $data->{ARGS}->{IMG_PROJ};
    my $srcname = $data->{ARGS}->{IMG_NAME};
    my $srctime = $data->{ARGS}->{IMG_TIME};
    my $srcsize = $data->{ARGS}->{IMG_SIZE};

    # Arg checking and untainting.
    if (!$proj || !$srcname || !$srctime || !defined($srcsize)) {
	warn "tbadb_serv::rpc_checkimage: Argument(s) missing from RPC!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Argument(s) missing.");
	exit 1;
    }
    if ($proj !~ /^([-\w]+)$/) {
	warn "tbadb_serv::rpc_checkimage: Malformed project argument!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Malformed project argument.");
	exit 1;
    }
    $proj = $1;
    if ($srcname !~ /^([-\.\w]+)$/) {
	warn "tbadb_serv::rpc_checkimage: Malformed image name argument!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Malformed image name argument.");
	exit 1;
    }
    $srcname = $1;

    warn "tbadb_serv::rpc_checkimage: Image check requested for $proj/$srcname\n";

    # Grab the lock for this image.
    my $lres = TBScriptLock("${proj}_${srcname}", TBSCRIPTLOCK_GLOBALWAIT,
			    $IMGLOCK_TMO, \$g_imglock);
    LOCKSW: for ($lres) {
	$_ == TBSCRIPTLOCK_IGNORE && do {
	    # Another process just did the check/transfer, so we're done.
	    if (!SendRPCData($RPCOUT, EncodeResult($data->{FID}, { NEED_IMG => 0 }))) {
		warn "tbadb_serv::rpc_checkimage: Error sending RPC result. Exiting!\n";
		exit 1;
	    }
	    return;
	};
	$_ == TBSCRIPTLOCK_OKAY && do {
	    # Got the lock, just bail out of here and proceed.
	    last LOCKSW;
	};
	# Default case (error condition)
	warn "tbadb_serv::rpc_checkimage: Failed to get lock for: $proj/$srcname\n";
	send_error($data->{FID}, RPCERR_INTERNAL, "Internal file handling error.");
	exit 1;	
    }

    my $projdir = "$IMAGE_CACHE/$proj";
    if (!-d $projdir) {
	if (!mkdir($projdir, 0750)) {
	    warn "tbadb_serv::rpc_checkimage: Failed to create project image directory: $projdir: $!\n";
	    send_error($data->{FID}, RPCERR_INTERNAL, "Internal file handling error.");
	    exit 1;
	}
    }

    my $lrufile = "$projdir/.$srcname.lru";
    my $imgfile = "$projdir/$srcname";
    if (-f $imgfile) {
	# Was the cached image placed (created) more recently than the
	# timestamp provided for the upstream version? Is the size different?
	my @imstats = stat($imgfile);
	my $imtime = $imstats[9];
	my $imsize = $imstats[7];
	warn "rpc_checkimage: UPSTREAM stats: $srcname, $srctime, $srcsize\n"
	    if $debug;
	warn "rpc_checkimage: LOCAL stats:    $srcname, $imtime, $imsize\n"
	    if $debug;
	if ($imtime >= $srctime && $imsize == $srcsize) {
	    if (!SendRPCData($RPCOUT, EncodeResult($data->{FID}, { NEED_IMG => 0 }))) {
		warn "tbadb_serv::rpc_checkimage: Error sending RPC result. Exiting!\n";
		exit 1;
	    }
	    TBScriptUnlock($g_imglock);
	    return;
	} else {
	    # Delete older existing image to make way for new version.
	    if (!unlink($imgfile)) {
		warn "tbadb_serv::rpc_checkimage: Could not remove old image: $imgfile\n";
		send_error($data->{FID}, RPCERR_INTERNAL, "Failed to remove older version of image.");
		exit 1;
	    }
	}
    }

    # Touch image's LRU file (even though the image may not have been
    # transferred yet; presumably it will be shortly).
    if (system($TOUCH, "$lrufile") != 0) {
	warn "tbadb_serv::rpc_checkimage: Could not update timestamp on $lrufile!\n";
	send_error($data->{FID}, RPCERR_INTERNAL, "Internal file handling error.");
	exit 1;
    }

    # Check to see if we are over quota, and LRU prune if so.
    if (!do_lru_cleanup()) {
	warn "tbadb_serv::rpc_checkimage: Error cleaning up cache. Exiting!\n";
	send_error($data->{FID}, RPCERR_INTERNAL, 
		   "Failed while cleaning up image cache.");
	exit 1;
    }

    # If we need/want to enforce some concurrency limits from this side,
    # we could send back a "WAIT" result here, which would tell the caller
    # to wait for some amount of time (maybe we specify), then call again.

    # Request that the image be transferred over (scp from boss)
    if (!SendRPCData($RPCOUT,
	     EncodeResult($data->{FID}, 
			  { NEED_IMG => 1, 
			    REMOTE_PATH => "$projdir" }))) {
	warn "tbadb_serv::rpc_checkimage: Error sending RPC result. Exiting!\n";
	exit 1;
    }

    # Note: We will unlock later in a subsequent rpc_loadimage call. If
    # that call never comes, we will eventually timeout while waiting for it
    # and exit, thus releasing the lock as well.
    return;
}


sub rpc_loadimage($) {
    my ($data) = @_;

    # Check and untaint arguments
    my $node_id = $data->{ARGS}->{NODE_ID};
    my $imgname = $data->{ARGS}->{IMG_NAME};
    my $proj    = $data->{ARGS}->{IMG_PROJ};
    if (!$imgname || !$node_id || !$proj) {
	warn "tbadb_serv::rpc_loadimage: missing RPC arguments!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Missing arguments.");
	exit 1;
    }
    if ($proj !~ /^([-\w]+)$/) {
	warn "tbadb_serv::rpc_loadimage: Malformed project argument!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Malformed project argument.");
	exit 1;
    }
    $proj = $1;
    if ($imgname !~ /^([-\.\w]+)$/) {
	warn "tbadb_serv::rpc_loadimage: Malformed image name argument!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Malformed image name argument.");
	exit 1;
    }
    $imgname = $1;
    if ($node_id !~ /^([-\w]+)$/) {
	warn "tbadb_serv::rpc_loadimage: Malformed node_id argument!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Malformed node_id argument.");
	exit 1;
    }
    $node_id = $1;
    if (!exists($NMAP{$node_id})) {
	warn "tbadb::rpc_loadimage: unknown/bad node_id: $node_id\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Unknown/bad node_id.");
	exit 1;
    }
    my $serial = $NMAP{$node_id};
    # Let anyone blocked on the transfer of this image proceed now.
    TBScriptUnlock($g_imglock)
	if fileno($g_imglock);
    my $fname = "$IMAGE_CACHE/$proj/$imgname";
    if (!-f $fname) {
	warn "tbadb_serv::rpc_loadimage: no such image file: $fname\n";
	send_error($data->{FID}, RPCERR_BADARGS, "No such image.");
	exit 1;
    }

    # Load image on to unit and report success/fail to caller.
    warn "tbadb_serv::rpc_loadimage: loading image $proj/$imgname on to $node_id\n";
    
    # Step 1: Make sure all required image files are present.
    my $image_staging_dir = "$fname.work";
    my $sysdir = "$IMAGE_CACHE/PNSYSTEM";
    my $recovery_image = "$sysdir/pnet-recovery.img";
    my $userdata_image = "$sysdir/pnet-userdata.img";
    my $cache_image = 
	-r "$image_staging_dir/cache.img" 
	? "$image_staging_dir/cache.img" 
	: "$sysdir/pnet-cache.img";
    my $boot_image = "$image_staging_dir/boot.img";
    # This may block.
    if (!unpack_bundle($fname, $image_staging_dir)) {
	warn "tbadb_serv::rpc_loadimage: Could not unpack image bundle!\n";
	send_error($data->{FID}, RPCERR_INTERNAL, "Image unpack failed.");
	exit 1;
    }
    if (!-r $boot_image) {
	warn "tbadb_serv::rpc_loadimage: boot.img missing from bundle!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "boot.img missing from bundle.");
	exit 1;
    }
    my $system_image = "$image_staging_dir/system.img";
    if (!-r $system_image) {
	warn "tbadb_serv::rpc_loadimage: system.img missing from bundle!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "system.img missing from bundle.");
	exit 1;
    }

    # Step 2: Reload the partitions based on the images we setup above.
    if (!-r $recovery_image || !-r $boot_image || #!-r $userdata_image ||
	!-r $cache_image || !-r $system_image ) {
	warn "tbadb_serv::rpc_loadimage: one or more images missing!\n";
	send_error($data->{FID}, RPCERR_INTERNAL, "Missing images.");
	exit 1;
    }
    if (!enter_fastboot($node_id)) {
	warn "tbadb_serv::rpc_loadimage: failed to boot $node_id into fastboot!\n";
	send_error($data->{FID}, RPCERR_NODE_ERR, "Node failed to load into fastboot.");
	exit 1;
    }
    if (!(#load_android_image($node_id, IMG_RECOVERY, $recovery_image) &&
	  load_android_image($node_id, IMG_BOOT,     $boot_image) &&
	  #load_android_image($node_id, IMG_USERDATA, $userdata_image) &&
	  load_android_image($node_id, IMG_CACHE,    $cache_image) &&
	  load_android_image($node_id, IMG_SYSTEM,   $system_image)
	)) {
	warn "tbadb_serv::rpc_loadimage: failed to load images on $node_id!\n";
	send_error($data->{FID}, RPCERR_NODE_ERR, "Failed to load images.");
	exit 1;
    }

    # Step 3: reboot into newly loaded image
    if (!reboot_android($node_id)) {
	warn "tbadb_serv::rpc_loadimage: newly loaded image failed to boot!\n";
	send_error($data->{FID}, RPCERR_NODE_ERR, "Failed to boot newly loaded image.");
	exit 1;
    }

    # Send success result back to caller.
    warn "tbadb::rpc_loadimage: finished loading $proj/$imgname on $node_id\n";
    SendRPCData($RPCOUT, EncodeResult($data->{FID}, { SUCCESS => 1 }));
    return;
}


sub rpc_captureimage($) {
    my ($data) = @_;

    # XXX: fill me in!
    warn "tbadb_serv::rpc_captureimage: Called...\n";
    send_error($data->{FID}, RPCERR_NOTIMPL, "captureimage not implemented yet.");
    return;
}


sub rpc_reboot($) {
    my ($data) = @_;

    my $node_id = $data->{ARGS}->{NODE_ID};
    my $dowait  = $data->{ARGS}->{WAIT};

    # Do a bit of arg checking.
    $dowait = defined($dowait) && int($dowait) ? 1 : 0;
    if (!$node_id) {
	warn "tbadb_serv::rpc_reboot: No node_id provided in RPC args!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "node_id missing.");
	exit 1;
    }
    if (!exists($NMAP{$node_id})) {
	warn "tbadb::rpc_loadimage: unknown/bad node_id: $node_id\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Unknown/bad node_id.");
	exit 1;
    }
    my $serial = $NMAP{$node_id};

    # Reboot the unit.
    warn "tbadb_serv::rpc_reboot: rebooting node $node_id\n";
    if (!reboot_android($node_id)) {
	warn "tbadb_serv::rpc_reboot: failed to reboot $node_id!\n";
	send_error($data->{FID}, RPCERR_NODE_ERR, "Reboot failed.");
	exit 1;
    }

    # Wait for device to boot up, if requested to do so.
    if ($dowait) {
	warn "tbadb_serv::rpc_reboot: waiting for $node_id to come up.\n";
	if (!wait_for_node($node_id)) {
	    warn "tbadb_serv::rpc_reboot: failed waiting for $node_id to boot!\n";
	    send_error($data->{FID}, RPCERR_NODE_ERR, "Boot failed.");
	    exit 1;
	}
    }

    # Report success.
    warn "tbadb_serv::rpc_reboot: reboot of $node_id finished.\n";
    SendRPCData($RPCOUT, EncodeResult($data->{FID}, { SUCCESS => 1 }));
    return;
}


sub rpc_forward($) {
    my ($data) = @_;

    my $node_id  = $data->{ARGS}->{NODE_ID};
    my $thost    = $data->{ARGS}->{TARGET_HOST};

    if (!$node_id || !$thost) {
	warn "tbadb_serv::rpc_forward: Missing RPC args!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "One or more arguments missing.");
	exit 1;
    }
    if ($node_id !~ /^([-\w]+)$/) {
	warn "tbadb_serv::rpc_forward: Malformed node_id argument!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Malformed node_id argument.");
	exit 1;
    }
    $node_id = $1;
    if ($thost !~ /^([-\.\w]+)$/) {
	warn "tbadb_serv::rpc_forward: Malformed target host argument!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Malformed target host argument.");
	exit 1;
    }
    $thost = $1;
    if (!exists($NMAP{$node_id})) {
	warn "tbadb::rpc_forward: unknown/bad node_id: $node_id\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Unknown/bad node_id.");
	exit 1;
    }
    my $serial = $NMAP{$node_id};

    # Setup forwarding from the ADB daemon on the unit to the
    # destionation port, and report back to caller!
    warn "tbadb_serv::rpc_forward: fowarding ADB on node $node_id to destination host $thost\n";
    my $port = setup_android_forward($node_id, $thost);
    if (!$port) {
	warn "tbadb_serv::rpc_forward: failed to setup adb port forwarding for $node_id to $thost\n";
	send_error($data->{FID}, RPCERR_NODE_ERR, "adb forwarding failed.");
	exit 1;
    }

    # Report success.
    warn "tbadb_serv::rpc_forward: forwarding setup for $node_id finished.\n";
    SendRPCData($RPCOUT, EncodeResult($data->{FID}, { PORT => $port }));
    return;
}


sub rpc_unforward($) {
    my ($data) = @_;

    my $node_id  = $data->{ARGS}->{NODE_ID};

    if (!$node_id) {
	warn "tbadb_serv::rpc_unforward: Missing node_id argument!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "node_id argument missing.");
	exit 1;
    }
    if ($node_id !~ /^([-\w]+)$/) {
	warn "tbadb_serv::rpc_unforward: Malformed node_id argument!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Malformed node_id argument.");
	exit 1;
    }
    $node_id = $1;

    # Setup forwarding from the ADB daemon on the unit to the
    # destionation port, and report back to caller!
    warn "tbadb_serv::rpc_unforward: removing ADB forwarding setup for node $node_id\n";
    if (!remove_android_forward($node_id)) {
	warn "tbadb_serv::rpc_unforward: failed to clear adb port forwarding for $node_id!\n";
	send_error($data->{FID}, RPCERR_NODE_ERR, "adb forwarding removal failed.");
	exit 1;
    }

    # Report success.
    warn "tbadb_serv::rpc_unforward: forwarding cleared for $node_id\n";
    SendRPCData($RPCOUT, EncodeResult($data->{FID}, { SUCCESS => 1 }));
    return;
}


sub rpc_nodewait($) {
    my ($data) = @_;

    my $node_id  = $data->{ARGS}->{NODE_ID};

    if (!$node_id) {
	warn "tbadb_serv::rpc_nodewait: Missing node_id argument!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "node_id argument missing.");
	exit 1;
    }
    if ($node_id !~ /^([-\w]+)$/) {
	warn "tbadb_serv::rpc_nodewait: Malformed node_id argument!\n";
	send_error($data->{FID}, RPCERR_BADARGS, "Malformed node_id argument.");
	exit 1;
    }
    $node_id = $1;

    # Wait for a while for the node to appear in adb.
    warn "tbadb_serv::rpc_nodewait: waiting for $node_id to become available.\n";
    if (!wait_for_android($node_id)) {
	warn "tbadb_serv::rpc_nodewait: failed while waiting for $node_id!\n";
	send_error($data->{FID}, RPCERR_NODE_ERR, "node wait failed.");
	exit 1;
    }

    # Report success.
    warn "tbadb_serv::rpc_nodewait: $node_id is now ready.\n";
    SendRPCData($RPCOUT, EncodeResult($data->{FID}, { SUCCESS => 1 }));
    return;
}


sub rpc_ping($) {
    my ($data) = @_;

    SendRPCData($RPCOUT, EncodeResult($data->{FID}, { PONG => 1 }));
    return;
}


sub rpc_exit($) {
    my ($data) = @_;

    # Send acknowledgement and exit.  No arguments expected.
    SendRPCData($RPCOUT, EncodeResult($data->{FID}, { SUCCESS => 1 }));
    exit 0;
}

##############################################################################
#
# Helper functions follow.
#

# Simple shorthand wrapper that sends an error back to the caller.
sub send_error($$$) {
    my ($fid, $code, $message) = @_;

    # Send failure result back.
    return SendRPCData($RPCOUT, EncodeError($fid, $code, $message));
}

# Helper that does LRU on our image cache
sub do_lru_cleanup() {
    my $tot = 0;
    my @files = ();
    my $err = 0;
    my $lru_lock;

    # Make sure the cache dir actually exists.
    if (!-d $IMAGE_CACHE) {
	warn "tbadb_serv::do_lru_cleanup: Image dir is not valid: $IMAGE_CACHE\n";
	return 0;
    }

    # Grab the global LRU lock.
    # XXX: We should also skip this process if we did it recently.
    my $lock_res = TBScriptLock("lrulock", TBSCRIPTLOCK_GLOBALWAIT,
				$LRULOCK_TMO, \$lru_lock);
    LOCKSW: for ($lock_res) {
	$_ == TBSCRIPTLOCK_IGNORE && do {
	    # Another process just did the LRU, so let's not do it again.
	    return 1;
	};
	$_ == TBSCRIPTLOCK_OKAY && do {
	    # Got the lock, just bail out of here and proceed.
	    last LOCKSW;
	};
	# Default case (error condition)
	warn "tbadb_serv::do_lru_cleanup: Failed to get the LRU lock!\n";
	return 0;
    }

    # Read entries in cache dir and tally size
    my $dh;
    if (!opendir($dh, $IMAGE_CACHE)) {
	warn "tbadb_serv::do_lru_cleanup: Failed to clean up img dir!\n";
	goto BADLRU;
    }
    while (my $ent = readdir($dh)) {
	my $dname = "$IMAGE_CACHE/$ent";
	next if ($ent =~ /^\..*$/ || !-d $dname);
	next if ($ent eq "PNSYSTEM"); # Skip system dir.
	my $subdh;
	if (!opendir($subdh, $dname)) {
	    warn "tbadb_serv::do_lru_cleanup: Could not descend into $dname\n";
	    $err = 1;
	    last;
	}
	while (my $subent = readdir($subdh)) {
	    next if ($subent =~ /^\..*$/);
	    my $imfile  = "$dname/$subent";
	    my $lrufile = "$dname/.$subent.lru";
	    if (!-e $lrufile) {
		warn "tbadb_serv::do_lru_cleanup: creating missing LRU file for: $imfile";
		if (system($TOUCH, "$lrufile") != 0) {
		    warn "tbadb_serv::do_lru_cleanup: could not create LRU file: $lrufile\n";
		    $err = 1;
		    last;
		}
	    }
	    my $lutime  = (stat($lrufile))[9];
	    my $imsize  = (stat($imfile))[7];
	    if (!defined($lutime) || $lutime < 0) {
		warn "tbadb_serv::do_lru_cleanup: Something weird happened while trying to stat $lrufile!\n";
		$err = 1;
		last;
	    }
	    if (!defined($imsize) || $imsize < 0) {
		warn "tbadb_serv::do_lru_cleanup: Something weird happened while trying to stat $imfile!\n";
		$err = 1;
		last;
	    }
	    warn "tbadb_serv::do_lru_cleanup: image file found: $ent/$subent:$lutime:$imsize\n"
		if $debug;
	    push @files, [$imfile, $lutime, $imsize];
	    $tot += $imsize;
	}
	close $subdh;
	last if $err;
    }
    close $dh;
    goto BADLRU if $err;

    # Prune?
    if ($tot > $WM_HIGH) {
	warn "tbadb_serv::do_lru_cleanup: Invoking LRU cleanup ($tot)\n";
	my @sortedfiles = sort { $a->[1] <=> $b->[1] } @files;
	while ($tot > $WM_LOW && scalar(@sortedfiles)) {
	    my ($imfile, undef, $imsize) = @{shift(@sortedfiles)};
	    $imfile =~ /^(.+)\/(.+)$/;
	    my $lrufile = "$1/.$2.lru";
	    if (!unlink($imfile, $lrufile)) {
		warn "tbadb_serv::do_lru_cleanup: Could not remove $imfile: $!\n";
		goto BADLRU;
	    }
	    warn "tbadb_serv::do_lru_cleanup: removed file $imfile\n";
	    $tot -= $imsize;
	}
	if ($tot > $WM_LOW) {
	    warn "Unable to prune enough images to get under low watermark ($WM_LOW)!\n";
	    goto BADLRU;
	}
    }

    TBScriptUnlock($lru_lock);
    return 1;

  BADLRU:
    TBScriptUnlock($lru_lock);
    return 0;
}

# Unpack a zip bundle containting one or more android image files. Do NOT
# call this function without a lock!  It should not run in parallel across
# tbadb_serv processes for the same image bundle.
sub unpack_bundle($$) {
    my ($fname, $destdir) = @_;
    my $unpack_lock;

    # Grab the unpack lock.
    if (TBScriptLock("unpacklock", undef, 
		     $UNPACKLOCK_TMO, \$unpack_lock) != TBSCRIPTLOCK_OKAY) {
	warn "tbadb_serv::unpack_bundle: Failed to get the unpack lock!\n";
	return 0;
    }

    # Make sure image is a zip bundle
    my $ftype = `$FILE -b -i $fname 2>&1`;
    if ($ftype !~ /application\/zip/) {
	warn "tbadb_serv::unpack_bundle: file is not a zip bundle: $fname\n";
	goto BADUNPACK;
    }
    # Delete the old destdir if it exists and is older than the image.
    if (-d $destdir &&
	(stat($destdir))[9] < (stat($fname))[9]) {
	if (system("$RM -rf $destdir >/dev/null 2>&1") != 0) {
	    warn "tbadb_serv::unpack_bundle: could not remove existing workdir for image bundle: $fname\n";
	    goto BADUNPACK;
	}
    }
    # If the image directory doesn't exist, we must unpack!
    if (!-d $destdir) {
	if (!mkdir($destdir, 0750)) {
	    warn "tbadb_serv::unpack_bundle: could not create workdir for image bundle: $fname: $!\n";
	    goto BADUNPACK;
	}
	if (system("$UNZIP -d $destdir $fname >/dev/null 2>&1") != 0) {
	    warn "tbadb_serv::unpack_bundle: failed to unpack image bundle: $fname\n";
	    goto BADUNPACK;
	}
    }

    TBScriptUnlock($unpack_lock);
    return 1;

  BADUNPACK:
    TBScriptUnlock($unpack_lock);
    return 0;
}

# Put a given android device into fastboot mode.
sub enter_fastboot($) {
    my ($node_id) = @_;

    my $serial = $NMAP{$node_id};
    if (!$serial) {
	warn "tbadb_serv::enter_fastboot: No serial number for $node_id!\n";
	return 0;
    }

    # First see if it is already sitting in fastboot.
    my $state = `$FASTBOOT devices 2>&1`;
    return 1 if $state =~ /$serial\s+fastboot/;

    # Next try to reboot via adb if adbd is running on the device.
    $state = `$ADB -s $serial get-state 2>&1`;
    chomp $state;
    if ($state ne "unknown") {
	if (system("$ADB -s $serial reboot-bootloader > /dev/null 2>&1") != 0) {
	    warn "Failed to reboot $node_id via adb!\n";
	    return 0;
	}
	# Now wait for fastboot to see it
	my $stime = time();
	while (1) {
	    sleep 5;
	    $state = `$FASTBOOT devices 2>&1`;
	    return 1 if $state =~ /$serial\s+fastboot/;
	    if (time() - $stime > $FASTBOOT_TMO) {
		warn "tbadb_serv::enter_fastboot: timed out waiting for $node_id\n";
		return 0;
	    }
	}
    }

    warn "tbadb_serv::enter_fastboot: Could not find device!\n";
    return 0;
}

# Flash an image to a device on the given partition.
sub load_android_image($$$) {
    my ($node_id, $partition, $impath) = @_;

    my $serial = $NMAP{$node_id};
    if (!$serial) {
	warn "tbadb_serv::load_android_image: No serial number for $node_id!\n";
	return 0;
    }

    my $state = `$FASTBOOT devices 2>&1`;
    if ($state !~ /$serial\s+fastboot/) {
	warn "tbadb_serv::load_android_image: device $node_id is not in fastboot. Can't flash image!";
	return 0;
    }

    my $imgout = `$FASTBOOT -u -s $serial flash $partition $impath 2>&1`;
    if ($?) {
	warn "tbadb_serv::load_android_image: fastboot failed to flash $partition with $impath on $node_id!\n";
	warn "Output:\n$imgout\n";
	return 0;
    }

    return 1;
}

# Reboot a device, but don't wait for it to come up.
sub reboot_android($) {
    my ($node_id) = @_;

    my $serial = $NMAP{$node_id};
    if (!$serial) {
	warn "tbadb_serv::reboot_android: No serial number for $node_id!\n";
	return 0;
    }

    # Figure out if node is setting in fastboot or regular boot, and reboot.
    my $state = `$FASTBOOT devices 2>&1`;
    if ($state =~ /$serial\s+fastboot/) {
	if (system("$FASTBOOT -s $serial reboot >/dev/null 2>&1") != 0) {
	    warn "tbadb_serv::reboot_android: fastboot failed to reboot $node_id!\n";
	    return 0;
	}
    } else {
	$state = `$ADB -s $serial get-state 2>&1`;
	chomp $state;
	if ($state ne "unknown") {
	    if (system("$ADB -s $serial reboot") != 0) {
		warn "tbadb_serv::reboot_android: adb failed to reboot $node_id!\n";
		return 0;
	    }
	} else {
	    warn "tbadb_serv::reboot_android: could not find device $node_id!\n";
	    return 0;
	}
    }

    # We don't wait for the node to come up...
    return 1;
}

# Helper that waits (bounded by a timeout) for a device to become available
# via adb.
sub wait_for_android($) {
    my ($node_id) = @_;

    my $serial = $NMAP{$node_id};
    if (!$serial) {
	warn "tbadb_serv::wait_for_android: No serial number for $node_id!\n";
	return 0;
    }

    my $stime = time();
    while (1) {
	my $state = `$ADB -s $serial get-state 2>&1`;
	chomp $state;
	if ($state eq "device") {
	    last;
	}
	if (time() - $stime > $ANDROID_BOOT_TMO) {
	    warn "tbadb_serv::wait_for_android: timed out waiting for $node_id to boot!\n";
	    return 0;
	}
	sleep 5;
    }

    return 1;
}

# Helper that sets up adb listener port for a device
sub setup_android_forward($$;$$) {
    my ($node_id, $thost, $port, $locknload) = @_;
    my $fwd_lock;

    $locknload = defined($locknload) ? $locknload : 1;

    my $serial = $NMAP{$node_id};
    if (!$serial) {
	warn "tbadb_serv::setup_android_forward: No serial number for $node_id!\n";
	return 0;
    }

    # Resolve the IP address for the target host if necessary
    if ($thost !~ /^\d+\.\d+\.\d+\.\d+$/) {
	my $tres = `$HOST -t A $thost 2>&1`;
	if ($tres =~ /has address ([\.\d]+)/) {
	    $thost = $1;
	} else {
	    warn "tbadb_serv::setup_android_forward: could not lookup ip for host $thost\n";
	    return 0;
	}
    }

    # Lock-n-load bro!
    if ($locknload) {
	if (TBScriptLock("fwdports", undef, 
			 $FWDLOCK_TMO, \$fwd_lock) != TBSCRIPTLOCK_OKAY) {
	    warn "tbadb_serv::setup_android_forward: Failed to get the forwarding lock!\n";
	    return 0;
	}
	# Tie to the forwarding ports DB file.
	if (!tie(%FWDPORTS, 'DB_File', $FWDDBFILE, 
		 O_RDWR | O_CREAT, 0755, $DB_HASH)) {
	    warn "tbadb::setup_android_forward: unable to load forwarding database!\n";
	    goto BADFWD;
	}
    }

    # Scour any existing forwarding setup for the device
    if (!remove_android_forward($node_id, 0)) {
	warn "tbadb_serv::setup_android_forward: could not remove old forwarding setup for $node_id!\n";
	goto BADFWD;
    }

    # Pick an available port (if not specified, which is an internal option).
    if (!$port) {
	my $pnum;
	for ($pnum = $MINPORT; $pnum < $MAXPORT; $pnum++) {
	    next if (exists($FWDPORTS{$pnum}));
	    my $tsock = IO::Socket::INET->new(LocalPort => $pnum, Listen => 5, 
					      Proto => "tcp");
	    next if (!$tsock);
	    close($tsock);
	    last;
	}
	if ($pnum >= $MAXPORT) {
	    warn "tbadb_serv::setup_android_forward: No available ports!\n";
	    goto BADFWD;
	}
	$port = $pnum;
    }
    $FWDPORTS{$port} = "$node_id,$thost";

    # Setup iptables rule to only allow connections from target
    if (system("$IPTABLES -A INPUT ! -s $thost -p tcp --dport $port -m comment --comment '$serial' -j DROP >/dev/null 2>&1") != 0) {
	warn "tbadb_serv::setup_android_forward: could not setup iptables rule to limit connections for $node_id via port $port to target host IP $thost\n";
	goto BADFWD;
    }

    # Forward!
    if (system("$ADB -s $serial forward tcp:$port tcp:5555 >/dev/null 2>&1") != 0) {
	warn "tbadb_serv::setup_android_forward: could not forward adbd port on node_id to local port $port!\n";
	goto BADFWD;
    }

    if ($locknload) {
	untie(%FWDPORTS);
	TBScriptUnlock($fwd_lock);
    }
    return $port;

  BADFWD:
    if ($locknload) {
	untie(%FWDPORTS);
	TBScriptUnlock($fwd_lock);
    }
    return 0;
}

# Helper that removes the adb forwading setup for a device.
sub remove_android_forward($;$) {
    my ($node_id, $locknload) = @_;
    my $fwd_lock;

    # We lock-n-load unless told not to!
    $locknload = defined($locknload) ? $locknload : 1;

    my $serial = $NMAP{$node_id};
    if (!$serial) {
	warn "tbadb_serv::remove_android_forward: No serial number for $node_id!\n";
	return 0;
    }

    # Lock-n-load bro!
    if ($locknload) {
	# Grab forwarding lock
	if (TBScriptLock("fwdports", undef, 
			 $FWDLOCK_TMO, \$fwd_lock) != TBSCRIPTLOCK_OKAY) {
	    warn "tbadb_serv::remove_android_forward: Failed to get the forwarding lock!\n";
	    return 0;
	}
	# Tie to the forwarding ports DB file.
	if (!tie(%FWDPORTS, 'DB_File', $FWDDBFILE, 
		 O_RDWR | O_CREAT, 0755, $DB_HASH)) {
	    warn "tbadb::remove_android_forward: unable to load forwarding database!\n";
	    goto BADFWD;
	}
    }

    # Clear the adb forwarding.
    my $adb_fwd_list = `$ADB forward --list 2>&1`;
    if ($? != 0) {
	warn "tbadb_serv::remove_android_forward: unable to list adb forwarded ports!\n";
	goto BADFWD;
    }
    my $portnum = 0;
    foreach my $fwd (split(/\n/, $adb_fwd_list)) {
	if ($fwd =~ /^$serial\s+tcp:(\d+)\s+/i) {
	    $portnum = $1;
	    last;
	}
    }
    if ($portnum && system("$ADB -s $serial forward --remove tcp:$portnum >/dev/null 2>&1") != 0) {
	warn "tbadb_serv::remove_android_forward: unable to remove adb forward for $node_id!\n";
	goto BADFWD;
    }

    # Clear the iptables rule.
    my $ipt_rules = `$IPTABLES -L INPUT --line-numbers 2>&1`;
    if ($? != 0) {
	warn "tbadb_serv::remove_android_forward: unable to list iptables rules!\n";
	goto BADFWD;
    }

    my $rulenum = 0;
    foreach my $rule (split(/\n/, $ipt_rules)) {
	if ($rule =~ /^(\d+)\s+.+\/\* $serial \*\//i) {
	    $rulenum = $1;
	    last;
	}
    }
    if ($rulenum && system("$IPTABLES -D INPUT $rulenum >/dev/null 2>&1") != 0) {
	warn "tbadb_serv::remove_android_forward: unable to clear iptables rule for $node_id!\n";
	goto BADFWD;
    }

    # Remove all entries for device from forwarding table hash
    while (my ($pnum, $ent) = each %FWDPORTS) {
	my ($nid, undef) = split(/,/, $ent);
	if ($nid eq $node_id) {
	    delete $FWDPORTS{$pnum};
	}
    }

    # Done.
    if ($locknload) {
	untie(%FWDPORTS);
	TBScriptUnlock($fwd_lock);
    }
    return 1;

  BADFWD:
    if ($locknload) {
	untie(%FWDPORTS);
	TBScriptUnlock($fwd_lock);
    }
    return 0;
}

# Helper that ensures adb server is running, fowarding is setup,
# and iptables rules are in place.
sub check_adb() {
    my $fwd_lock;
    my %adb_p2s = ();
    my %ipt_p2s = ();
    my %ipt_p2h = ();

    warn "tbadb_serv::check_adb: Running check.\n"
	if $debug;

    # Grab forwarding lock (doubles as IPT lock).
    if (TBScriptLock("fwdports", undef, 
		     $FWDLOCK_TMO, \$fwd_lock) != TBSCRIPTLOCK_OKAY) {
	warn "tbadb_serv::check_adb: Failed to get the forwarding lock!\n";
	return 0;
    }

    # Ensure rule to block remote traffic to adb server is in place.
    my $rules = `$IPTABLES -L INPUT -n`;
    if ($? != 0) {
	warn "tbadb_serv::check_adb: failed to list ipt rules!\n";
	goto BADCHK;
    }
    my $srvfound = 0;
    foreach my $rule (split(/\n/, $rules)) {
	$srvfound = 1 if ($rule =~ /^DROP.*dpt:5037/);
	if ($rule =~ /^DROP\s+tcp\s+--\s+!([\.\d]+)\s.+dpt:(\d+)\s+\/\* (\w+) \*\//i) {
	    my ($thost, $port, $serial) = ($1, $2, $3);
	    $ipt_p2s{$port} = $serial;
	    $ipt_p2h{$port} = $thost;
	}
    }
    if (!$srvfound) {
	warn "tbadb_serv::check_adb: adding ipt block rule for adb server.\n";
	if(system("$IPTABLES -A INPUT ! -s localhost -p tcp -m tcp --dport 5037 -j DROP") != 0) {
	    warn "tbadb_serv::check_adb: failed to add ipt rule to block traffic to adb server!\n";
	    goto BADCHK;
	}
    }

    # Make sure the adb server is running.
    my $isrunning = 
	system("$PS auxwww | $GREP 'adb.*fork-server' | $GREP -qv grep") == 0;
    if (!$isrunning) {
	warn "tbadb_serv::check_adb: (re)starting adb server.\n";
	if (system("$ADB -a -P 5037 fork-server server &") != 0) {
	    warn "tbadb_serv::check_adb_server: could not start adb server!\n";
	    goto BADCHK;
	}
	sleep 2;
    }

    # Tie to the forwarding ports DB file.
    if (!tie(%FWDPORTS, 'DB_File', $FWDDBFILE, 
	     O_RDWR | O_CREAT, 0755, $DB_HASH)) {
	warn "tbadb_serv::check_adb: unable to load forwarding database!\n";
	goto BADCHK;
    }

    # Get the set of ADB forwarded ports.
    my $adb_fwd_list = `$ADB forward --list 2>&1`;
    if ($? != 0) {
	warn "tbadb_serv::check_adb: unable to list adb forwarded ports!\n";
	goto BADCHK;
    }
    foreach my $fwd (split(/\n/, $adb_fwd_list)) {
	if ($fwd =~ /^(\w+)\s+tcp:(\d+)\s+/i) {
	    my ($serial, $port) = ($1, $2);
	    $adb_p2s{$port} = $serial;
	}
    }

    # First, sync up entries for devices in the forwarding database.
    my @todo = ();
    while (my ($port, $val) = each %FWDPORTS) {
	my ($node_id, $thost) = split(/,/, $val);
	my $serial = $NMAP{$node_id};
	if (!$serial) {
	    warn "tbadb_serv::check_adb: no serial number found for $node_id!\n";
	    delete $FWDPORTS{$port};
	    next;
	}

	if (!exists($adb_p2s{$port}) ||
	    !exists($ipt_p2s{$port}) ||
	    $thost ne $ipt_p2h{$port}) 
	{
	    # Untaint since these came from a file (tied hash).
	    $node_id =~ /^([-\w]+)$/;
	    $node_id = $1;
	    $thost =~ /^([-\.\w]+)$/;
	    $thost = $1;
	    $port =~ /^(\d+)$/;
	    $port = $1;
	    push @todo, [$node_id, $thost, $port];
	}
	delete $adb_p2s{$port};
	delete $ipt_p2s{$port};
	delete $ipt_p2h{$port};
    }
    map { my ($n,$th,$p) = @{$_}; setup_android_forward($n,$th,$p,0) } @todo;

    # Now get rid of entries we don't have a fowarding record
    # for. These will be all records left in the hashes built up
    # earlier in this function.
    while (my ($port, $serial) = each %adb_p2s) {
	system("$ADB -s $serial forward --remove tcp:$port >/dev/null 2>&1") == 0 
	    or warn "tbadb_serv::check_adb: Could not remove stale ADB forwarding entry: $serial,$port\n";
    }
    while (my ($port, $serial) = each %ipt_p2s) {
	my $thost = $ipt_p2h{$port};
	system("$IPTABLES -D INPUT ! -s $thost -p tcp --dport $port -m comment --comment '$serial' -j DROP >/dev/null 2>&1") == 0
	    or warn "tbadb_serv::check_adb: Could not remove stale IPT filter rule: $thost,$port,$serial\n";
    }

    warn "tbadb_serv::check_adb: Done checking.\n"
	if $debug;

    untie(%FWDPORTS);
    TBScriptUnlock($fwd_lock);
    return 1;

  BADCHK:
    untie(%FWDPORTS);
    TBScriptUnlock($fwd_lock);
    return 0;
}
