#!/usr/bin/perl -w
#
# Copyright (c) 2008-2014 University of Utah and the Flux Group.
# 
# {{{GENIPUBLIC-LICENSE
# 
# GENI Public License
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and/or hardware specification (the "Work") to
# deal in the Work without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Work, and to permit persons to whom the Work
# is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Work.
# 
# THE WORK IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS
# IN THE WORK.
# 
# }}}
#
use strict;
use English;
use Getopt::Std;
use XML::Simple;
use File::Temp qw(tempfile :POSIX );
use Data::Dumper;
use Cwd qw(realpath);

#
# Create a quick VM.
# 
sub usage()
{
    print "Usage: quickvm [-u uuid] [-a aggregate] <xmlfile>\n";
    print "Usage: quickvm -k <uuid>\n";
    print "Usage: quickvm -e <seconds> <uuid>\n";
    print "Usage: quickvm -s <uuid> <sliver_urn> <imagename>\n";
    print "Usage: quickvm -c <uuid> <sliver_urn>\n";
    exit(1);
}
my $optlist = "dkve:u:a:st:fc";
my $debug   = 0;
my $verbose = 1;
my $killit  = 0;
my $utahddc = 1;
my $DDCURN  = "urn:publicid:IDN+utahddc.geniracks.net+authority+cm";
my $xmlfile;
my $extend;
my $webtask;
my $webtask_id;
my $snapshot;
my $consoleurl;
my $foreground = 0;
my $localuser  = 0;
my $quickuuid;
my $aggregate;
my $this_user;

# Protos
sub fatal($);
sub UserError($);
sub Terminate($);
sub Extend($$);
sub SnapShot($$$);
sub GenCredentials($$$$);
sub ConsoleURL($$);

#
# Configure variables
#
my $TB		  = "@prefix@";
my $TBOPS         = "@TBOPSEMAIL@";
my $TBLOGS        = "@TBLOGSEMAIL@";
my $OURDOMAIN     = "@OURDOMAIN@";
my $MAINSITE      = @TBMAINSITE@;
my $PGENIDOMAIN   = "@PROTOGENI_DOMAIN@";
my $SACERT	  = "$TB/etc/genisa.pem";
my $CMCERT	  = "$TB/etc/genicm.pem";
my $SSHKEYGEN     = "/usr/bin/ssh-keygen";
my $SSHSETUP      = "$TB/sbin/aptssh-setup";
my $ADDPUBKEY     = "$TB/sbin/addpubkey";
my $UPDATEGENIUSER= "$TB/sbin/protogeni/updategeniuser";
my $GENEXTENDCRED = "$TB/sbin/protogeni/genextendcred";
my $VERSIONING    = @PROFILEVERSIONS@;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin:/usr/site/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1; 

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libtestbed;
use libaudit;
use APT_Profile;
use APT_Instance;
use User;
use OSinfo;
use emutil;
use GeniDB;
use GeniUser;
use GeniCertificate;
use GeniCredential;
use GeniSlice;
use GeniAuthority;
use GeniHRN;
use Genixmlrpc;
use GeniResponse;
use GeniXML;
use WebTask;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"a"})) {
    $aggregate = $options{"a"};
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"c"})) {
    $consoleurl = 1;
}
if (defined($options{"v"})) {
    $verbose = 1;
}
if (defined($options{"f"})) {
    $foreground = 1;
}
if (defined($options{"k"})) {
    $killit = 1;
}
if (defined($options{"s"})) {
    $snapshot = 1;
}
if (defined($options{"e"})) {
    $extend = $options{"e"};
}
if (defined($options{"t"})) {
    $webtask_id = $options{"t"};
}
if (defined($options{"u"})) {
    $quickuuid = $options{"u"};
}
if (@ARGV < 1) {
    usage();
}
if ($killit) {
    $quickuuid = shift(@ARGV);
}
elsif ($extend) {
    if ($extend !~ /^\d*$/) {
	usage();
    }
    $quickuuid = shift(@ARGV);
}
elsif ($snapshot) {
    usage()
	if (@ARGV != 3);
    
    $quickuuid = shift(@ARGV);
}
elsif ($consoleurl) {
    usage()
	if (@ARGV != 2);
    
    $quickuuid = shift(@ARGV);
}
else {
    $xmlfile = shift(@ARGV);

    #
    # Check the filename when invoked from the web interface; must be a
    # file in /tmp.
    #
    if (getpwuid($UID) ne "nobody") {
	$this_user = User->ThisUser();

	if (! defined($this_user)) {
	    fatal("You ($UID) do not exist!");
	}
	$localuser = 1;
    }
    if (!defined($this_user) || !$this_user->IsAdmin()) {
	if ($xmlfile =~ /^([-\w\.\/]+)$/) {
	    $xmlfile = $1;
	}
	else {
	    fatal("Bad data in pathname: $xmlfile");
	}

	# Use realpath to resolve any symlinks.
	my $translated = realpath($xmlfile);
	if ($translated =~ /^(\/tmp\/[-\w\.\/]+)$/) {
	    $xmlfile = $1;
	}
	else {
	    fatal("Bad data in translated pathname: $xmlfile");
	}
    }
}

# Email record.
if (! $debug) {
    AuditStart(0, undef, LIBAUDIT_LOGTBLOGS()|LIBAUDIT_LOGONLY());
    AddAuditInfo("cc", "aptnet-logs\@flux.utah.edu");
}

# Connect to the SA DB.
DBConnect(GENISA_DBNAME());

#
# Load the SA cert to act as caller context.
#
my $sa_certificate = GeniCertificate->LoadFromFile($SACERT);
if (!defined($sa_certificate)) {
    fatal("Could not load certificate from $SACERT\n");
}
my $sa_authority = GeniAuthority->Lookup($sa_certificate->urn());
if (!defined($sa_authority)) {
    fatal("Could not load SA authority object");
}
my $speaker_signer = $GeniCredential::LOCALSA_FLAG;

#
# We want to contact our local CM to create the sliver.
# We use the normal XMLRPC route.
#
my $context = Genixmlrpc->Context($sa_certificate);
if (!defined($context)) {
    fatal("Could not create context to talk to CM");
}
Genixmlrpc->SetContext($context);

#
# Load the CM authority, since that is who we talk to.
#
my $CMURN;

if (defined($aggregate)) {
    $CMURN = $aggregate;
}
elsif ($utahddc) {
    $CMURN = $DDCURN;
}
else {
    my $cm_certificate = GeniCertificate->LoadFromFile($CMCERT);
    if (!defined($cm_certificate)) {
	fatal("Could not load certificate from $CMCERT\n");
    }
    $CMURN = $cm_certificate->urn();
}
my $cm_authority = GeniAuthority->Lookup($CMURN);
if (!defined($cm_authority)) {
    $cm_authority = GeniAuthority->CreateFromRegistry("cm", $CMURN);
    if (!defined($cm_authority)) {    
	fatal("Could not load CM authority object");
    }
}

if ($killit) {
    exit(Terminate($quickuuid));
}
elsif ($extend) {
    exit(Extend($quickuuid, $extend));
}
elsif ($snapshot) {
    exit(SnapShot($quickuuid, $ARGV[0], $ARGV[1]));
}
elsif ($consoleurl) {
    exit(ConsoleURL($quickuuid, $ARGV[0]));
}

#
# Must wrap the parser in eval since it exits on error.
#
my $xmlparse = eval { XMLin($xmlfile,
			    VarAttr => 'name',
			    ContentKey => '-content',
			    SuppressEmpty => undef); };
fatal($@)
    if ($@);
print STDERR Dumper($xmlparse)
    if ($debug || $verbose);

#
# Make sure all the required arguments were provided.
#
foreach my $key ("username", "email", "profile") {
    fatal("Missing required attribute '$key'")
	if (! (exists($xmlparse->{'attribute'}->{"$key"}) &&
	       defined($xmlparse->{'attribute'}->{"$key"}) &&
	       $xmlparse->{'attribute'}->{"$key"} ne ""));
}

#
# Gather up args and sanity check.
#
my ($value, $user_urn, $user_uid, $user_hrn, $user_email,
    $sshkey, $profile, $version);

#
# Username and email has to be acceptable to Emulab user system.
#
$value = $xmlparse->{'attribute'}->{"username"}->{'value'};
if (! TBcheck_dbslot($value, "users", "usr_name",
		     TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
    fatal("Illegal username: $value");
}
$user_uid = $value;
$user_urn = GeniHRN::Generate("$OURDOMAIN", "user", $user_uid);
$user_hrn = "${PGENIDOMAIN}.${user_uid}";

$value = $xmlparse->{'attribute'}->{"email"}->{'value'};
if (! TBcheck_dbslot($value, "users", "usr_email",
		     TBDB_CHECKDBSLOT_WARN|TBDB_CHECKDBSLOT_ERROR)) {
    fatal("Illegal email address: $value");
}
$user_email = $value;

#
# Not many choices; see if it exists.
#
$value = $xmlparse->{'attribute'}->{"profile"}->{'value'};
# This is a safe lookup.
my $profile_object = APT_Profile->Lookup($value);
if (!defined($profile_object)) {
    fatal("No such profile: $value");
}
my $rspecstr = $profile_object->CheckFirewall(!$localuser);
$profile = $profile_object->profileid();
$version = $profile_object->version();

#
# Use ssh-keygen to see if the key is valid and convertable. We first
# try to get the fingerprint, which will tells us if its already in
# openssh format. If not, try to convert it.
#
if (exists($xmlparse->{'attribute'}->{"sshkey"}) &&
    defined($xmlparse->{'attribute'}->{"sshkey"}) &&
    $xmlparse->{'attribute'}->{"sshkey"} ne "") {
    $sshkey = $xmlparse->{'attribute'}->{"sshkey"}->{'value'};
    my ($fh, $keyfile) = tempfile(UNLINK => 0);
    print $fh $sshkey;

    if (system("$SSHKEYGEN -l -f $keyfile >/dev/null 2>/dev/null")) {
	if (! open(KEYGEN, "$SSHKEYGEN -i -f $keyfile 2>/dev/null |")) {
	    fatal("Could not start ssh-keygen");
	}
	$sshkey = <KEYGEN>;
	if (!close(KEYGEN)) {
	    UserError("Could not parse ssh key!");
	}
    }
    close($fh);
    unlink($keyfile);
}
chomp($sshkey)
    if (defined($sshkey));

#
# See if the GeniUser exists. Create if not, but that means we
# have to create an ssl certificate (which the user will never see)
# so that we can operate on behalf of the user (via speaksfor).
#
# Note that we want to check for the user local account ahead of
# SA account, to bypass their guest account that might still be
# in the table.
#
my $geniuser;

if ($localuser) {
    $geniuser = GeniUser::LocalUser->Lookup($user_uid);
}
else {
    $geniuser = GeniUser->Lookup($user_urn);

    #
    # In Utah, check for alternate SA
    #
    if (!defined($geniuser) && $MAINSITE) {
	$user_urn = GeniHRN::Generate("aptlab.net", "user", $user_uid);
	$user_hrn = "aptlab.${user_uid}";
	$geniuser = GeniUser->Lookup($user_urn, 0);
    }
}
if (!defined($geniuser)) {
    if ($localuser) {
	fatal("Could not lookup local user $user_urn");
    }
    
    #
    # Do not allow overlap with local users.
    #
    if (User->Lookup($user_uid)) {
	fatal("User $user_uid exists in the local user table");
    }

    print "Geni user does not exist; creating one ...\n"
	if ($debug);

    #
    # Want to remember the auth token we emailed for later.
    #
    my $auth_token = $xmlparse->{'attribute'}->{"auth_token"}->{'value'};
    if ($auth_token !~ /^[\w]+$/) {
	fatal("Bad auth token: $auth_token");
    }
    my $blob = {"urn"      => $user_urn,
		"hrn"      => $user_hrn,
		"email"    => $user_email,
		"showuuid" => 1};
    if ($MAINSITE) {
	$blob->{'useaptca'} = 1;
    }
    my $certificate = GeniCertificate->Create($blob);
    fatal("Could not create certificate")
	if (!defined($certificate));

    $geniuser = GeniUser->Create($certificate, $sa_authority);
    fatal("Could not create new geni user")
	if (!defined($geniuser));

    $geniuser->SetAuthToken($auth_token);

    #
    # Setup browser ssh.
    #
    system("$SSHSETUP " . $geniuser->uuid());
    fatal("Could not create ssh key pair")
	if ($?);
}
my $user_uuid = $geniuser->uuid();
# So we know this user has dome something lately.
$geniuser->BumpActivity();

#
# Guest users use the apt CA, and so we must sign the speaksfor
# credential with the APT SA as well so that the target of the
# speaksfor credential is in the same namespace as the signer.
#
if (!$localuser && $MAINSITE) {
    $speaker_signer = "/usr/testbed/etc/utah-apt.sa";
}

if ($localuser) {
    my $emulab_user = $geniuser->emulab_user();
    if ($emulab_user->IsNonLocal()) {
	system("$UPDATEGENIUSER -s " . $emulab_user->uid());
	if ($?) {
	    fatal("Could not update ssh keys for nonlocal user");
	}
    }
    elsif (!$emulab_user->isEmulab() && defined($sshkey) &&
	   !$emulab_user->LookupSSHKey($sshkey)) {
	$emulab_user->DeleteSSHKeys();
	my ($fh, $keyfile) = tempfile(UNLINK => 0);
	print $fh $sshkey;

	if (system("$ADDPUBKEY -u $user_uid -f $keyfile")) {
	    fatal("Could not add new ssh pubkey");
	}
	close($fh);
	unlink($keyfile);
    }
}
elsif (!$localuser && defined($sshkey)) {
    #
    # Remember key. For now we accept only one key. We store it simply
    # so we can display it again for the user in the web interface.
    # We allow key reuse for existing users, see above.
    #
    $geniuser->DeleteKeys();
    $geniuser->AddKey($sshkey);
}
# There will be "internal" keys cause we pass the flag asking for them.
my @sshkeys;
if ($geniuser->GetKeyBundle(\@sshkeys, 1) < 0 || !@sshkeys) {
    fatal("No ssh keys to use for $geniuser!");
}

#
# Now generate a slice registration and credential
#
my $safe_uid    = $user_uid; $safe_uid =~ s/_/-/;
my $slice_id    = $safe_uid . "-QV" . TBGetUniqueIndex('next_quickvm', 1);
my $slice_urn   = GeniHRN::Generate($OURDOMAIN, "slice", $slice_id);
my $slice_hrn   = "${PGENIDOMAIN}.${slice_id}";
my $SERVER_NAME = (exists($ENV{"SERVER_NAME"}) ? $ENV{"SERVER_NAME"} : "");

print STDERR "\n";
print STDERR "$user_urn\n";
print STDERR "$slice_urn\n";
print STDERR "$SERVER_NAME\n";
print STDERR "\n";
print STDERR "$rspecstr\n";

#
# Make sure slice is unique. Probably retry here at some point. 
#
if (GeniSlice->Lookup($slice_hrn) || GeniSlice->Lookup($slice_urn)) {
    fatal("Could not form a unique slice name");
}
	    
#
# Generate a certificate for this new slice.
#
my $slice_certificate =
    GeniCertificate->Create({'urn'  => $slice_urn,
			     'hrn'  => $slice_hrn,
			     'showuuid' => 1,
			     'email'=> $user_email});

if (!defined($slice_certificate)) {
    fatal("Could not generate certificate for $slice_urn");
}
# Slice is created as locked.
my $slice = GeniSlice->Create($slice_certificate,
			      $geniuser, $sa_authority, undef, 1);
if (!defined($slice)) {
    $slice_certificate->Delete();
    fatal("Could not create new slice object for $slice_urn");
}
# These get quick expirations, unless it is a real user.
if ($slice->SetExpiration(time() + (($localuser ? 16 : 3) * 3600)) != 0) {
    $slice->Delete();
    fatal("Could not set the slice expiration for $slice_urn");
}
my $slice_uuid = $slice->uuid();

#
# Generate credentials we need.
#
my ($slice_credential, $speaksfor_credential) =
    GenCredentials($slice, $geniuser, $sa_authority, $speaker_signer);
if (! (defined($speaksfor_credential) &&
       defined($slice_credential))) {
    $slice->Delete();
    fatal("Could not generate credentials");
}

#
# Got this far, lets create a quickvm record.
#
my $quickvm_uuid = (defined($quickuuid) ? $quickuuid : NewUUID());
if (!defined($quickvm_uuid)) {
    fatal("Could not generate a new uuid");
}
my $instance = APT_Instance->Create({'uuid'         => $quickvm_uuid,
				     'profile_id'   => $profile,
				     'profile_version' => $version,
				     'slice_uuid'   => $slice_uuid,
				     'creator'      => $geniuser->uid(),
				     'creator_idx'  => $geniuser->idx(),
				     'creator_uuid' => $geniuser->uuid(),
				     'aggregate_urn'=> $CMURN,
				     'status'       => "created",
				     'servername'   => $SERVER_NAME});
if (!defined($instance)) {
    $slice->Delete();
    fatal("Could not create instance record for $quickvm_uuid");
}
#
# Create a webtask so that we can store additional information about
# the sliver while we wait. No worries if this fails.
#
$webtask = WebTask->Create($instance->uuid());
$webtask->AutoStore(1)
    if (defined($webtask));

#
# Exit and let caller poll for status.
#
if (!$debug) {
    my $child = fork();
    if ($child) {
	# Parent exits but avoid libaudit email.
	exit(0);
    }
    # Let parent exit;
    sleep(2);
    # All of the logging magic happens in here.
    libaudit::AuditFork();
}
# Bind the process id.
$webtask->SetProcessID($PID)
    if (defined($webtask));

#
# This creates the sliver and starts it.
#
my $response =
    Genixmlrpc::CallMethod($cm_authority->url(), undef,
			   "CreateSliver",
			   { "slice_urn"   => $slice_urn,
			     "rspec"       => $rspecstr,
			     "keys"        =>
				 [{'urn'   => $user_urn,
				   'login' => $user_uid,
				   'keys'  => \@sshkeys }],
			     "credentials" =>
				 [$slice_credential->asString(),
				  $speaksfor_credential->asString()]});

if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS) {
    $slice->Delete();
    $instance->SetStatus("failed");
    if (defined($webtask)) {
	if (defined($response)) {
	    $webtask->output($response->output());
	    $webtask->Exited($response->code());
	}
	else {
	    $webtask->Exited(1);
	}
    }
    fatal("CreateSliver failed: ".
	  (defined($response) ? $response->output() : "") . "\n");
}

#
# We are going to use the manifests table.
#
my $manifest = $response->value()->[1];
if (!defined($manifest)) {
    $slice->UnLock();
    $webtask->Exited(1) if (defined($webtask));
    $instance->SetStatus("failed");
    fatal("Could not find the manifest in the response!");
}
$instance->SetStatus("provisioned");
$instance->SetManifest($manifest);

#
# but have to wait for the sliver to be ready, which means polling.
#
my $seconds  = 1500;
my $interval = 15;
my $ready    = 0;
my $failed   = 0;
my $public_url;

while ($seconds > 0) {
    sleep($interval);
    $seconds -= $interval;
    
    my $response =
	Genixmlrpc::CallMethod($cm_authority->url(), undef,
			       "SliverStatus",
			       { "slice_urn"   => $slice_urn,
				 "credentials" =>
				     [$slice_credential->asString(),
				      $speaksfor_credential->asString()]});

    if (!defined($response) || !defined($response->value()) ||
	($response->code() != GENIRESPONSE_SUCCESS &&
	 $response->code() != GENIRESPONSE_BUSY)) {
	print STDERR "SliverStatus failed";
	if (defined($response)) {
	    print STDERR ": " . $response->output();
	    if (defined($webtask)) {
		$webtask->output($response->output());
	    }
	}
	print STDERR "\n";
	$failed = 1;
	last;
    }
    next
	if ($response->code() == GENIRESPONSE_BUSY);

    my $blob = $response->value();
    if (exists($blob->{'public_url'})) {
	$public_url = $blob->{'public_url'};
    }
    if ($blob->{'status'} eq "ready") {
	$ready = 1;
	last;
    }
    elsif ($blob->{'status'} eq "failed") {
	$failed = 1;
	last;
    }
}
print STDERR "$slice_urn\n";
print STDERR "$public_url\n"
    if (defined($public_url));
print STDERR "\n";
print STDERR "$manifest\n\n";

if ($failed || !$ready) {
    $instance->SetStatus("failed");
    if (!$ready) {
	print STDERR "$slice_urn timed out.\n";
    }
    else {
	print STDERR "$slice_urn failed.\n"; 
    }
    $webtask->Exited(1) if (defined($webtask));
}
else {
    $instance->SetStatus("ready");
    $webtask->Exited(0) if (defined($webtask));
}
$slice->UnLock();
exit(0);

sub fatal($) {
    my ($mesg) = $_[0];

    print STDERR "*** $0:\n".
	         "    $mesg\n";
    exit(-1);
}
sub UserError($) {
    my($mesg) = $_[0];

    AuditAbort()
	if (!$debug);
    print $mesg;
    exit(1);
}

#
# Generate or yank the speaks for credential out of the DB.
#
sub GenCredentials($$$$)
{
    my ($target, $geniuser, $authority, $signer) = @_;
    my ($speaksfor, $credential);

    #
    # If a local user account, but a nonlocal id, then we should
    # have a speaksfor credential stored, as well as a certificate
    # for the user.
    #
    if ($geniuser->IsLocal() && $geniuser->emulab_user()->IsNonLocal()) {
	my ($speaksfor_string, $certificate_string) =
	    $geniuser->emulab_user()->GetStoredCredential();
	if (! (defined($speaksfor_string) &&
	       defined($certificate_string))) {
	    print STDERR "No stored speaksfor/certificate for $geniuser\n";
	    goto bad;
	}
	$speaksfor = GeniCredential->CreateFromSigned($speaksfor_string);
	if (!defined($speaksfor)) {
	    print STDERR "Could not create speaksfor credential\n";
	    goto bad;
	}
	my $certificate =
	    GeniCertificate->LoadFromString($certificate_string);
	if (!defined($certificate)) {
	    print STDERR "Could not load certificate from string\n";
	    goto bad;
	}
	$credential = GeniCredential->Create($target, $certificate);
    }
    else {
	$speaksfor = GeniCredential->Create($geniuser, $authority);
	if (!defined($speaksfor)) {
	    print STDERR "Could not create speaksfor credential\n";
	    goto bad;
	}
	$speaksfor->SetType("speaksfor");
	if ($speaksfor->Sign($signer)) {
	    print STDERR "Could not sign speaksfor credential\n";
	    goto bad;
	}
	$credential = GeniCredential->Create($target, $geniuser);
    }
    if (!defined($credential)) {
	print STDERR "Could not create credential for $target\n";
	goto bad;
    }
    # And sign it.
    if ($credential->Sign($GeniCredential::LOCALSA_FLAG) != 0) {
	$credential->Delete();
	print STDERR "Could not sign $target credential\n";
	goto bad;
    }
    return ($credential, $speaksfor);
  bad:
    return ();
}

#
# Terminate a quick VM.
#
sub Terminate($)
{
    my ($uuid) = @_;

    my $instance = APT_Instance->Lookup($uuid);
    if (! defined($instance)) {
	fatal("No such quick VM: $uuid");
    }
    if (defined($instance->aggregate_urn()) &&
	$instance->aggregate_urn() ne $CMURN) {
	$CMURN = $instance->aggregate_urn();
	
	$cm_authority = GeniAuthority->Lookup($CMURN);
	if (!defined($cm_authority)) {
	    $cm_authority = GeniAuthority->CreateFromRegistry("cm", $CMURN);
	    if (!defined($cm_authority)) {    
		fatal("Could not load CM authority object");
	    }
	}
    }
    my $geniuser = GeniUser->Lookup($instance->creator_uuid(), 1);
    if (!defined($geniuser)) {
	fatal("No creator for quick VM: $uuid");
    }
    my $slice = GeniSlice->Lookup($instance->slice_uuid());
    if (!defined($slice)) {
	goto killit;
    }
    #
    # Generate credentials we need.
    #
    my ($slice_credential, $speaksfor_credential) =
	GenCredentials($slice, $geniuser, $sa_authority, $speaker_signer);
    if (! (defined($speaksfor_credential) &&
	   defined($slice_credential))) {
	fatal("Could not generate credentials");
    }

    #
    # Lock the slice in case it is doing something else, like taking
    # a disk image.
    #
    if ($slice->Lock()) {
	fatal("Slice is busy, cannot lock it");
    }
    my $old_status = $instance->status();
    $instance->SetStatus("terminating");

    #
    # Exit and let caller poll for status.
    #
    if (!$debug) {
	my $child = fork();
	if ($child) {
	    # Parent exits but avoid libaudit email.
	    exit(0);
	}
	# Let parent exit;
	sleep(2);
	# All of the logging magic happens in here.
	libaudit::AuditFork();
    }
    #
    # We have to watch for resource busy errors, and retry. For a while
    # at least. Eventually give up cause it might be a permanently locked
    # slice cause of earlier error. 
    #
    my $tries = 10;
    while ($tries) {
	my $response =
	    Genixmlrpc::CallMethod($cm_authority->url(), undef,
				   "DeleteSlice",
				   { "slice_urn"   => $slice->urn(),
				     "credentials" =>
					 [$slice_credential->asString(),
					  $speaksfor_credential->asString()]});

	if (!defined($response) ||
	    ($response->code() != GENIRESPONSE_SUCCESS &&
	     $response->code() != GENIRESPONSE_SEARCHFAILED &&
	     $response->code() != GENIRESPONSE_BUSY)) {
	    $instance->SetStatus($old_status);
	    $slice->UnLock();
	    fatal("DeleteSlice failed: ".
		  (defined($response) ? $response->output() : "") . "\n");
	}
	last
	    if ($response->code() == GENIRESPONSE_SUCCESS ||
		$response->code() == GENIRESPONSE_SEARCHFAILED);

	#
	# Wait for a while and try again. 
	#
	$tries--;
	if ($tries) {
	    print STDERR "Slice is busy, will retry again in a bit ...\n";
	    sleep(30);
	}
    }
    if (!$tries) {
	$slice->UnLock();
	$instance->SetStatus($old_status);
	fatal("DeleteSlice failed: Slice was busy for way too long");
    }
    $slice->Delete();
  done:
    $instance->RecordHistory();
  killit:
    WebTask->DeleteByObject($instance);
    $instance->Delete();
    exit(0);
}

#
# Extend a quick VM.
#
sub Extend($$)
{
    my ($uuid, $seconds) = @_;

    my $instance = APT_Instance->Lookup($uuid);
    if (! defined($instance)) {
	fatal("No such quick VM: $uuid");
    }
    if (defined($instance->aggregate_urn()) &&
	$instance->aggregate_urn() ne $CMURN) {
	$CMURN = $instance->aggregate_urn();
	
	$cm_authority = GeniAuthority->Lookup($CMURN);
	if (!defined($cm_authority)) {
	    $cm_authority = GeniAuthority->CreateFromRegistry("cm", $CMURN);
	    if (!defined($cm_authority)) {    
		fatal("Could not load CM authority object");
	    }
	}
    }
    my $geniuser = GeniUser->Lookup($instance->creator_uuid(), 1);
    if (!defined($geniuser)) {
	fatal("No creator for quick VM: $uuid");
    }
    my $slice = GeniSlice->Lookup($instance->slice_uuid());
    if (!defined($slice)) {
	if ($instance->status() eq "failed") {
	    fatal("Cannot extend failed instance!");
	}
	fatal("No slice for quick VM: $uuid");
    }
    my $slice_urn  = $slice->urn();
    my $user_urn   = $geniuser->urn();
    my $oldexpires = $slice->expires();

    #
    # We need a special credentential in case the aggregate is enforcing
    # limits (as do Utah aggregates).
    #
    my $extcred  = "";
    my $credname = tmpnam();
    system("$GENEXTENDCRED -a -o $credname -s $slice_urn -u $user_urn -t 90");
    if ($?) {
	fatal("Could not create extended credential");
    }
    open(EXT, $credname) or fatal("Could not open ext credfile $credname");
    while (<EXT>) {
	$extcred .= $_;
    }
    close(EXT);
    unlink($credname);
    chomp($extcred);

    # Need to update slice before creating new credential. 
    $slice->AddToExpiration($extend);
    my $new_expires = $slice->ExpirationGMT();

    #
    # Generate credentials we need.
    #
    my ($slice_credential, $speaksfor_credential) =
	GenCredentials($slice, $geniuser, $sa_authority, $speaker_signer);
    if (! (defined($speaksfor_credential) &&
	   defined($slice_credential))) {
	$slice->SetExpiration($oldexpires);
	fatal("Could not generate credentials");
    }
    my $response =
	Genixmlrpc::CallMethod($cm_authority->url(), undef,
			       "RenewSlice",
			       { "slice_urn"  => $slice->urn(),
				 "expiration" => $new_expires,
				 "credentials" =>
				     [$slice_credential->asString(),
				      $speaksfor_credential->asString(),
				      $extcred]});

    if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS) {
	$slice->SetExpiration($oldexpires);
	if ($response->code() == GENIRESPONSE_REFUSED) {
	    UserError($response->output());
	}
	fatal("RenewSlice failed: ".
	      (defined($response) ? $response->output() : "") . "\n");
    }
    exit(0);
}

#
# SnapShot.
#
sub SnapShot($$$)
{
    my ($uuid, $sliver_urn, $imagename) = @_;

    $this_user = User->ThisUser();
    if (! defined($this_user)) {
	fatal("You ($UID) do not exist!");
    }
    my $instance = APT_Instance->Lookup($uuid);
    if (! defined($instance)) {
	fatal("No such quick VM: $uuid");
    }
    my $old_status = $instance->status();
    if ($old_status ne "ready") {
	fatal("Instance must be in the ready state to take a snapshot");
    }
    my $profile = $instance->Profile();
    if (! defined($profile)) {
	fatal("No profile for $instance");
    }
    if (defined($instance->aggregate_urn()) &&
	$instance->aggregate_urn() ne $CMURN) {
	$CMURN = $instance->aggregate_urn();
	
	$cm_authority = GeniAuthority->Lookup($CMURN);
	if (!defined($cm_authority)) {
	    $cm_authority = GeniAuthority->CreateFromRegistry("cm", $CMURN);
	    if (!defined($cm_authority)) {    
		fatal("Could not load CM authority object");
	    }
	}
    }
    my $geniuser = GeniUser->Lookup($instance->creator_uuid(), 1);
    if (!defined($geniuser)) {
	fatal("No creator for quick VM: $uuid");
    }
    my $slice = GeniSlice->Lookup($instance->slice_uuid());
    if (!defined($slice)) {
	if ($instance->status() eq "failed") {
	    goto done;
	}
	fatal("No slice for quick VM: $uuid");
    }

    #
    # Generate credentials we need.
    #
    my ($slice_credential, $speaksfor_credential) =
	GenCredentials($slice, $geniuser, $sa_authority, $speaker_signer);
    if (! (defined($speaksfor_credential) &&
	   defined($slice_credential))) {
	fatal("Could not generate credentials");
    }

    #
    # We do this with slice locked.
    #
    if ($slice->Lock()) {
	fatal("Slice is busy, cannot lock it");
    }

    #
    # We got a webtask ID, which means we want to store the status
    # in the webtask structure. Look it up, create if it does not
    # exist.
    #
    if (defined($webtask_id)) {
	$webtask = WebTask->Lookup($webtask_id);
	if (!defined($webtask)) {
	    fatal("Could not locate webtask for $webtask_id")
	}
    }
    $instance->SetStatus("imaging");

    # For debugging.
    my $cmurl = $cm_authority->url();
    #$cmurl =~ s/protogeni/protogeni\/stoller/;

    my $response =
	Genixmlrpc::CallMethod($cmurl, undef,
			       "CreateImage",
			       { "slice_urn"  => $slice->urn(),
				 "sliver_urn" => $sliver_urn,
				 "imagename"  => $imagename,
				 "credentials" =>
				     [$slice_credential->asString(),
				      $speaksfor_credential->asString()]});

    if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS) {
	$instance->SetStatus($old_status);
	$slice->UnLock();
	fatal("CreateImage failed: ".
	      (defined($response) ? $response->output() : "") . "\n");
    }
    my ($image_urn, $image_url,
	$version_urn, $version_url) = @{ $response->value() };
    if (!defined($version_urn)) {
	$version_urn = $image_urn;
	$version_url = $image_url
    }

    #
    # We got a webtask ID, which means we want to create a web task
    # structure to track its progress.
    #
    if (defined($webtask)) {
	$webtask->image_urn($version_urn);
	$webtask->image_url($version_url);
	$webtask->Store();
    }
    
    #
    # Exit and leave child to poll. We are looking for the sliver
    # to unlock, which means the createimage is done. What we do
    # not know is if it failed to actually create the image. Need
    # to think about this.
    #
    if (! ($debug || $foreground)) {
	my $child = fork();
	if ($child) {
	    # Parent exits but avoid libaudit email.
	    AuditAbort();
	    print "$image_urn,$image_url\n";
	    exit(0);
	}
	# Let parent exit;
	sleep(2);
	# All of the logging magic happens in here.
	libaudit::AuditFork();
    }
    # Bind the process id.
    $webtask->SetProcessID($PID)
	if (defined($webtask));
    
    my $seconds  = 1200;
    my $interval = 5;
    my $ready    = 0;
    my $failed   = 0;

    while ($seconds > 0) {
	sleep($interval);
	$seconds -= $interval;
    
	my $response =
	    Genixmlrpc::CallMethod($cmurl, undef,
				   "SliverStatus",
				   { "slice_urn"   => $slice->urn(),
				     "credentials" =>
					 [$slice_credential->asString(),
					  $speaksfor_credential->asString()]});

	if (!defined($response) || !defined($response->value()) ||
	    ($response->code() != GENIRESPONSE_SUCCESS &&
	     $response->code() != GENIRESPONSE_BUSY)) {
	    print STDERR "SliverStatus failed";
	    if (defined($response)) {
		print STDERR ": " . $response->output();
	    }
	    print STDERR "\n";
	    $failed = 1;
	    last;
	}
	next
	    if ($response->code() == GENIRESPONSE_BUSY);

	my $blob = $response->value();
	if (exists($blob->{'public_url'})) {
	    $public_url = $blob->{'public_url'};
	}
	if (defined($webtask)) {
	    #
	    # Need to find the sliver inside the blob.
	    #
	    my $sliverblob = $blob->{'details'}->{$sliver_urn};
	    if (defined($sliverblob)) {
		$webtask->state($sliverblob->{'state'});
		$webtask->rawstate($sliverblob->{'rawstate'});
		$webtask->Store();
	    }
	}
	if ($blob->{'status'} eq "failed") {
	    $failed = 1;
	    last;
	}
	#
	# We are watching for the image status to report ready or failed.
	#
	$response =
	    Genixmlrpc::CallMethod($cmurl, undef,
				   "ImageInfo",
				   { "image_urn"   => $image_urn,
				     "credentials" =>
					 [$slice_credential->asString(),
					  $speaksfor_credential->asString()]});

	if (!defined($response) || !defined($response->value()) ||
	    ($response->code() != GENIRESPONSE_SUCCESS &&
	     $response->code() != GENIRESPONSE_BUSY)) {
	    print STDERR "ImageInfo failed";
	    if (defined($response)) {
		print STDERR ": " . $response->output();
	    }
	    print STDERR "\n";
	    next;
	}
	next
	    if ($response->code() == GENIRESPONSE_BUSY);

	$blob = $response->value();

	if (defined($webtask)) {
	    if (exists($blob->{'size'})) {
		$webtask->image_size($blob->{'size'});
	    }
	    if (exists($blob->{'status'})) {
		$webtask->image_status($blob->{'status'});
	    }
	    $webtask->Store();
	}
	if ($blob->{'status'} eq "ready") {
	    $ready = 1;
	    last;
	}
	elsif ($blob->{'status'} eq "failed") {
	    $failed = 1;
	    last;
	}
    }
    if ($failed) {
	print STDERR "Imaging failed\n";
	$webtask->Exited(1)
	    if (defined($webtask));
	$slice->UnLock();
	exit(1);
    }
    elsif (!$ready) {
	print STDERR "Imaging timed out\n"; 
	$webtask->Exited(60)
	    if (defined($webtask));
	$slice->UnLock();
	exit(1);
    }
    else {
	#
	# If successful, we create a new version of the profile and
	# update the rspec to reflect the new image version. Note
	# that we expect the CM is doing image versioning, so do not
	# bother to check if the image version is actually new.
	#
	if ($VERSIONING) {
	    $profile = $profile->NewVersion($this_user);
	    if (!defined($profile)) {
		print STDERR "Could not create new profile version\n";
		$webtask->Exited(70)
		    if (defined($webtask));
		exit(1);
	    }
	}
	$profile->UpdateDiskImage($image_urn);
	$slice->UnLock();
	$instance->SetStatus("ready");
	# We garbage collect these later, so anyone waiting has a chance
	# to see the exit status
	$webtask->Exited(0)
	    if (defined($webtask));
	print "$image_urn,$image_url\n";
    }
  done:
    exit(0);
}

#
# Ask for a console URL for a node
#
sub ConsoleURL($$)
{
    my ($uuid, $sliver_urn) = @_;

    my $instance = APT_Instance->Lookup($uuid);
    if (! defined($instance)) {
	fatal("No such quick VM: $uuid");
    }
    if (defined($instance->aggregate_urn()) &&
	$instance->aggregate_urn() ne $CMURN) {
	$CMURN = $instance->aggregate_urn();
	
	$cm_authority = GeniAuthority->Lookup($CMURN);
	if (!defined($cm_authority)) {
	    $cm_authority = GeniAuthority->CreateFromRegistry("cm", $CMURN);
	    if (!defined($cm_authority)) {    
		fatal("Could not load CM authority object");
	    }
	}
    }
    my $geniuser = GeniUser->Lookup($instance->creator_uuid(), 1);
    if (!defined($geniuser)) {
	fatal("No creator for quick VM: $uuid");
    }
    my $slice = GeniSlice->Lookup($instance->slice_uuid());
    if (!defined($slice)) {
	if ($instance->status() eq "failed") {
	    goto done;
	}
	fatal("No slice for quick VM: $uuid");
    }

    #
    # Generate credentials we need.
    #
    my ($slice_credential, $speaksfor_credential) =
	GenCredentials($slice, $geniuser, $sa_authority, $speaker_signer);
    if (! (defined($speaksfor_credential) &&
	   defined($slice_credential))) {
	fatal("Could not generate credentials");
    }
    my $response =
	Genixmlrpc::CallMethod($cm_authority->url(), undef,
			       "ConsoleURL",
			       { "slice_urn"   => $slice->urn(),
				 "sliver_urn"  => $sliver_urn,
				 "credentials" =>
				     [$slice_credential->asString(),
				      $speaksfor_credential->asString()]});

    if (!defined($response) || $response->code() != GENIRESPONSE_SUCCESS) {
	if ($response->code() == GENIRESPONSE_REFUSED) {
	    UserError($response->output());
	}
	fatal("ConsoleURL failed: ".
	      (defined($response) ? $response->output() : "") . "\n");
    }
    my $url = $response->value();
    AuditAbort();
    print "$url\n";
    exit(0);
}


