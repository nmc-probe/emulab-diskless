#!/usr/local/bin/python
from BaseHTTPServer import BaseHTTPRequestHandler
import urlparse
import traceback
import os
import sys
import syslog
import mysql.connector

# This requires Python 2.6+
class Ec2MetaHandler(BaseHTTPRequestHandler):

    def __init__(self, req, ca, huh):
        self.cnx = mysql.connector.connect(user='tmcd',
                              database='tbdb', unix_socket='/tmp/mysql.sock')
        facil = "LOG_" + "@TBLOGFACIL@".upper()
        syslog.openlog("tmcd-meta", syslog.LOG_PID, getattr(syslog,facil))
        BaseHTTPRequestHandler.__init__(self,req,ca,huh)

    def log_message(self, format, *args):
        outtext = format
        alen = len(args)
        if alen == 0:
            outtext = format
        elif alen == 1:
            outtext = format % (args[0])
        elif alen == 2:
            outtext = format % (args[0], args[1])
        elif alen == 3:
            outtext = format % (args[0], args[1], args[2])
        elif alen == 4:
            outtext = format % (args[0], args[1], args[2], args[3])
        elif alen == 5:
            outtext = format % (args[0], args[1], args[2], args[3],
                        args[4])
        else:
            outtext = "Too many format strings"

        # All this retardness is because someone decided that 
        # that format string functionality was ONLY exposed
        # through a shitty operator(%) and not through a real
        # function, so now its impossible to use it with *args
        # because of some restrictive front end checks, meh
        syslog.syslog(outtext)

    def do_GET(self):
        parsed_path = urlparse.urlparse(self.path)

        only_path = parsed_path.path
        folders=[]
        while 1:
            only_path,folder=os.path.split(only_path)

            if folder != "":
                folders.append(folder)
            if only_path=="/":
                break;

        if len(folders) > 0:
            folders.pop() #Ignore version
        folders.reverse()

        try:
            message = self.handle_req(folders, self.metas)
            message = message + "\n"
        except Exception as e:
            syslog.syslog(traceback.format_exc())
            self.send_response(404)
            self.end_headers()
            return

        self.send_response(200)
        self.end_headers()
        self.wfile.write(message)
        return

    def listmetas(self, metas):
        message = "\n".join(map(lambda x: x + "/" if (x == "public-keys" or not(callable(metas[x])))  else x,
                        metas.keys()));
        return message

    def handle_req(self, arg, metas):
        if callable(metas):
            return metas(self, arg)
        elif len(arg) == 0:
            return self.listmetas(metas);
        else:
            return self.handle_req(arg[1:], metas[arg[0]])

    def do_userdata(self, arg):
        #TODO
        return "\n";

    def doamiid(self, arg):
        cursor = self.cnx.cursor()
        ip = self.client_address[0]
        cursor.execute("select osname from os_info "
            "join nodes on os_info.osid = nodes.osid "
            "join interfaces on nodes.node_id=interfaces.node_id "
            "where interfaces.ip=%s", (ip,));
        if cursor.with_rows:
            ami_id = cursor.fetchone()
            ami_id = ami_id[0]
        else:
            ami_id = ""
        cursor.close()
        return ami_id;

    def dolocal_hostname(self, args):
        cursor = self.cnx.cursor()
        ip = self.client_address[0]
        cursor.execute("select vname,eid,pid from reserved join interfaces on interfaces.node_id=reserved.node_id"
            " where interfaces.ip=%s",(ip,))
        if cursor.with_rows:
            node_id = cursor.fetchone()
        else:
            cursor.close()
            return ""

        cursor.close()
        return node_id[0] + "." + node_id[1] + "." + node_id[2] + "." + "emulab.net"

    def doavail(self, args):
        #TODO
        return "emulab"


    def domacs(self, args):
        #TODO
        return "324AF"

    def domac(self, args):
        cursor = self.cnx.cursor()
        ip = self.client_address[0]
        cursor.execute("select mac from interfaces"
            " where interfaces.ip=%s",(ip,))
        if cursor.with_rows:
            mac = cursor.fetchone()
        else:
            cursor.close()
            return ""

        cursor.close()
        split = [mac[0][i:i+2] for i in range(0, len(mac[0]),2)]
        return ":".join(split)

    def doinstance_id(self, args):
        cursor = self.cnx.cursor()
        ip = self.client_address[0]
        cursor.execute("select uuid from interfaces"
            " where interfaces.ip=%s",(ip,))
        if cursor.with_rows:
            uuid = cursor.fetchone()
        else:
            cursor.close()
            return ""

        cursor.close()
        return uuid[0]


    def dopublic_keys(self, args):
        if len(args) == 0:
            #Throw out all the users. Hope the stuff don't change between queries
            cursor = self.cnx.cursor()
            ip = self.client_address[0]
            cursor.execute("select user_pubkeys.uid,user_pubkeys.idx from user_pubkeys "
                "join group_membership on group_membership.uid = user_pubkeys.uid "
                "join experiments on experiments.pid=group_membership.pid AND experiments.gid=group_membership.gid "
                "join reserved on reserved.exptidx=experiments.idx "
                "join interfaces on reserved.node_id=interfaces.node_id "
                "where interfaces.ip=%s and user_pubkeys.uid=experiments.expt_swap_uid ORDER BY idx DESC "
                "UNION "
                "select user_pubkeys.uid,user_pubkeys.idx from user_pubkeys "
                "join group_membership on group_membership.uid = user_pubkeys.uid "
                "join experiments on experiments.pid=group_membership.pid AND experiments.gid=group_membership.gid "
                "join reserved on reserved.exptidx=experiments.idx "
                "join interfaces on reserved.node_id=interfaces.node_id "
                "where interfaces.ip=%s and user_pubkeys.uid!=experiments.expt_swap_uid;"
                , (ip,ip,))

            list = ""
            ctr = 0
            if cursor.with_rows:
                for (user,uid) in cursor:
                    list = list + str(ctr) + "=" + str(user) + str(uid) + "\n"
                    ctr = ctr+1
            else:
                cursor.close()
                return ""

            cursor.close()
            return list
        elif len(args) == 1:
            #TODO: Verify ig idx is within limits
            return "openssh-key"
        elif len(args) == 2:
            val = int(args[0])
            cursor = self.cnx.cursor()
            ip = self.client_address[0]
            cursor.execute("select * from "
                "((select user_pubkeys.pubkey from user_pubkeys "
                "join group_membership on group_membership.uid = user_pubkeys.uid "
                "join experiments on experiments.pid=group_membership.pid AND experiments.gid=group_membership.gid "
                "join reserved on reserved.exptidx=experiments.idx "
                "join interfaces on reserved.node_id=interfaces.node_id "
                "where interfaces.ip=%s and user_pubkeys.uid=experiments.expt_swap_uid ORDER BY idx DESC) "
                "UNION "
                "(select user_pubkeys.pubkey from user_pubkeys "
                "join group_membership on group_membership.uid = user_pubkeys.uid "
                "join experiments on experiments.pid=group_membership.pid AND experiments.gid=group_membership.gid "
                "join reserved on reserved.exptidx=experiments.idx "
                "join interfaces on reserved.node_id=interfaces.node_id "
                "where interfaces.ip=%s and user_pubkeys.uid!=experiments.expt_swap_uid)) "
                "as T limit " + str(val) + ", 1;",
                (ip, ip,))

            if cursor.with_rows:
                key = cursor.fetchone()
            else:
                cursor.close()
                return ""

            cursor.close()
            return key[0]

    metas = {
        "meta-data" : {
            "placement" : {"availability-zone" : doavail},
            "ami-id": doamiid,
            "local-hostname" : dolocal_hostname,
            "public-hostname":dolocal_hostname,
            "network": {"interfaces": {"macs" : domacs}},
            "mac":domac,
            "instance-id":doinstance_id,
            "public-keys": dopublic_keys },
        "user-data" : do_userdata
    }


if __name__ == '__main__':
    from BaseHTTPServer import HTTPServer
    import socket

    #
    # Daemonize. We redirect our output into a log file cause I have no
    # idea what is going to use plain print. 
    # Lifted from xmlrpc/sslxmlrpc_server.py.in
    #
    try:
        fp = open("@prefix@/log/tmcd-meta.log", "a");
        sys.stdout = fp
        sys.stderr = fp
        sys.stdin.close();
        pass
    except:
        print "Could not open log file for append"
        sys.exit(1);
        pass

    pid = os.fork()
    if pid:
        os.system("echo " + str(pid) + " > /var/run/tmcd-meta.pid")
        sys.exit(0)
        pass
    os.setsid();
    pass

    server = HTTPServer((socket.gethostbyname(socket.gethostname()), 8787),
            Ec2MetaHandler)
    server.serve_forever()


