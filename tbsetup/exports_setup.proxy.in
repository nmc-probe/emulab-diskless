#!/usr/bin/perl -wT

#
# Copyright (c) 2000-2015 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#

use English;
use Errno;
use Fcntl ':flock';
use Getopt::Std;

#
# Create and /etc/exports file based on current reserved table and project
# members.
#
# usage: exports_setup
#

my %opts = ();
getopts('Si', \%opts);

#
# Configure variables
#
my $TBOPS       = "@TBOPSEMAIL@";
my $LINUX_FSNODE= @LINUX_FSNODE@;
my $INC_MOUNTD  = @INCREMENTAL_MOUNTD@;

my $etcdir;
my $exports;
my $exportsnew;
my $exportsback;
my $exportshead;
my $exportstail;
my $pidfile;
my $daemon;
my $incremental;

# Are we modifying the Samba config file or the NFS exports?
if (defined($opts{'S'})) {
    $etcdir      = ($LINUX_FSNODE ? "/etc/samba" : "/usr/local/etc");
    $exports	 = "$etcdir/smb.conf";
    $exportsnew  = "$etcdir/smb.conf.new";
    $exportsback = "$etcdir/smb.conf.backup";
    $exportshead = "$etcdir/smb.conf.head";
    $exportstail = "$etcdir/smb.conf.tail";
    if (-r "/var/run/samba/smbd.pid") {
	$pidfile = "/var/run/samba/smbd.pid";
    } elsif (-r "/var/run/smbd.pid") {
	$pidfile = "/var/run/smbd.pid";
    } else {
	fatal("Cannot locate pidfile for smbd\n");
    }
    $daemon      = "smbd";
}
else {
    $etcdir      = "/etc";
    $exports	 = "$etcdir/exports";
    $exportsnew  = "$etcdir/exports.new";
    $exportsback = "$etcdir/exports.backup";
    $exportshead = "$etcdir/exports.head";
    $exportstail = "$etcdir/exports.tail";
    $pidfile     = "/var/run/mountd.pid";
    $daemon      = "mountd";
    $exportfs    = ($LINUX_FSNODE ? "/usr/sbin/exportfs -ra" : undef);

    # incremental only applies to mountd
    if (defined($opts{'i'})) {
	if ($INC_MOUNTD) {
	    $incremental = 1;
	} else {
	    print "WARNING: incremental updates not supported, ignoring option\n";
	}
    }
}

my $dbg		= 0;
my @row;

#
# We don't want to run this script unless its the real version.
#
if ($UID != 0) {
    die("Must be root!");
}

# un-taint path
$ENV{'PATH'} = '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$| = 1; #Turn off line buffering on output

#
# Testbed Support libraries
# 
use lib "@prefix@/lib";
use libtestbed;

#
# Take our input and write it to the tail file.
#
open(TAIL, ">$exportstail") || fatal("Couldn't open $exportstail\n");
while (<STDIN>) {
    print TAIL $_;
}
close(TAIL);
chmod(0444, $exportstail);

#
# Generate a warning so that no one tries to edit the file by hand
#
open(MAP, ">$exportsnew") || fatal("Couldn't open $exportsnew\n");
print MAP
    "#\n".
    "# ******************************************************************\n".
    "# DO NOT EDIT THIS FILE. IT IS A CREATION, A FIGMENT, A CONTRIVANCE!\n".
    "#\n".
    "# Edit $exportshead, then run exports_setup on boss.\n".
    "# ******************************************************************\n".
    "#\n";
close(MAP);
chmod(0644, $exportsnew);

#
# Now tack on the head part of the file.
#
system("cat $exportshead >> $exportsnew") == 0 or
    fatal("Failed to concat $exportshead to $exportsnew\n");

#
# Now the tail of the file.
# 
system("cat $exportstail >> $exportsnew") == 0 or
    fatal("Failed to concat $exportstail to $exportsnew\n");

#
# Do nothing if no change.
#
# Note that for now, we are actually saving the diffs so we can
# compare to the new differential behavior of mountd in case of
# an inconsisency. But only for mountd, not smbd.
#
my $outfile;
if (defined($opts{'S'})) {
    system("/usr/bin/diff -q $exports $exportsnew >/dev/null");
} else {
    $outfile = "/tmp/exports_diff." . time();
    system("/usr/bin/diff $exports $exportsnew >$outfile 2>&1");
}
if (! $?) {
#    print "No changes to $exports; skipping ...\n";
    unlink($outfile)
	if ($outfile);
    exit(0);
}

#
# Back up the existing exports, and then mv in the new one.
#
system("cp $exports $exportsback") == 0 or
    fatal("Could not back up $exports to $exportsback\n");

system("mv $exportsnew $exports") == 0 or
    fatal("Could not mv $exportsnew to $exports\n");

# Avoid accidental editing.
chmod(0444, $exports);

my $checkstamp = 0;
if (!$LINUX_FSNODE) {
    my $daemonpid = `cat $pidfile`;
    $daemonpid =~ s/\n//;
    # untaint
    if ($daemonpid =~ /^([-\@\w.]+)$/) {
	$daemonpid = $1;
    }

    #
    # Utah feature: if mountd is maintaining a timestamp file, we use
    # that to determine when it has finished processing the exports.
    #
    # XXX since mountd always blindly updates the file, we just remove it
    # here so we don't have to bother checking the content, we just have to
    # wait for it to exist.
    #
    if (!defined($opts{'S'}) && unlink("/var/run/mountd.ts") != 0) {
	$checkstamp = 1;
    }

    if ($incremental) {
	if (kill('USR1', $daemonpid) == 0) {
	    fatal("Could not kill(USR1) process $daemonpid ($daemon): $!");
	}
    } else {
	if (kill('HUP', $daemonpid) == 0) {
	    fatal("Could not kill(HUP) process $daemonpid ($daemon): $!");
	}
    }
}
else {
    # Not supporting Samba at this time. 
    if (! defined($opts{'S'})) {
	#
	# run exportfs. linux handles exports changes much more gracefully
	# then freebsd does.
	#
        system($exportfs) == 0 or
            fatal("Could not run $exportfs\n");
    }
}

#
# In FreeBSD, must allow time to react since HUP'ing mountd causes all
# mounts to briefly become invalid. Our caller (exports_setup) checks for
# this, but we need to make sure that processing has at least started!
#
# Note that Utah has hacked mountd to write a timestamp when it is done.
# Hence we can tell exactly when it has finished. In this case, our caller
# will not wait at all.
#
if ($checkstamp) {
    # On Utah Emulab with thousands of mount points, this can take 15 seconds!
    my $wtime = $incremental ? 8 : 15;

    for (my $i = 0; $i < $wtime; $i++) {
	print "exports_setup.proxy: waiting for mountd to finish ($i)...\n";
	if (-e "/var/run/mountd.ts") {
	    print "exports_setup.proxy: mountd done.\n";
	    last;
	}
	sleep(1);
    }
} else {
    sleep(1);
}

exit(0);

sub fatal {
    local($msg) = $_[0];

    SENDMAIL($TBOPS, "Exports Setup Failed", $msg);    
    die($msg);
}

