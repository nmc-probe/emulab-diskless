#
# Given two full images I1 and I2:
#
# I. Basic:
#
# 1. create a shiny new delta image (imagedelta) I2.ddz.v2
# 2. create a shiny new full image (imageundelta) I2.ndz.v2 from I1 and delta
# 3. compare sigs of I2.ndz and I2.ndz.v2
#
# What we learn: imagedelta/undelta don't crash on the image in question,
# delta/undelta are correct at the level of the signature file.
#
# II. More advanced:
#
# 4. lay down I1.ndz on a ramdisk and optionally verify against sig [4]
# 5. lay down I2.ndz on a ramdisk and optionally verify against sig [4]
# 6. create an old school delta image (imagezip -D) I2.ddz from I2 disk, I1 sig
# 7. compare sigs of I2.ddz I2.ddz.v2
# 7a. if sigs don't compare [1], we compare I2.ddz.v2 against the I2 disk
#
# What we learn: imagezip and imagedelta delta creation are consistent.
#
# III. Over the top:
#
# 8.  apply delta I2.ddz.v2 to I1 disk
# 9.  compare contents of I1 and I2 disks [2]
# 10. load full I2.ndz.v2 image on I3 disk
# 11. compare contents of I2 and I3 disks [3]
#
# What we learn: new format files can be loaded (imagezip), actual on-disk
# contents are correct.
#
# What is left behind:
#
# I[12].ndz and I[12].ndz.sig:
#    the original files we were working on.
# I2.ddz.new and I2.ddz.new.sig (all phases):
#    I2 delta image created with imagedelta.
# I2.ddz and I2.ddz.sig (phase 2 and 3 only):
#    I2 delta image created with imagezip from I2 disk and I1 signature.
# I2.ndz.new and I2.ndz.new.sig (phase 3 only):
#    full I2 image created with imageundelta
# I2.ndz.clean and I2.ndz.clean.sig (phase 3 only):
#    "clean" (-F 0) full I2 image recreated with imagezip from I2 disk.
#
# Footnotes:
#
# [1] Since delta signatures generated by imagezip are imperfect,
#     the sigs may not match. To ensure their equivalence, we assume
#     the imagezip sig is correct and verify the other by checking it
#     against the on-disk image.
#
# [2] We cannot just "cmp" the two disks due to inexactness of the
#     delta created by imagedelta. It may include unused blocks that
#     will get propogate back to disk. Hence, we create new image files
#     from both disks using imagezip--with "-F 0" to ensure no free sects
#     are included--and byte compare those image files.
#
# [3] As with imagedelta, imageundelta is inexact and may have included
#     garbage sectors from the original image. We perform the same
#     comparison as in [2] instead.
#
# [4] A freshly unzipped image can has imagehash errors if the image has
#     relocations.
#
my $TMPDIR = "/local/tmp";
my $LOGDIR = "/local/logs";
my @NEEDBINS = ("imagezip", "imageunzip", "imagehash", "imagedump",
    "imagedelta", "imageundelta");

my $MAXPHASE = 3;

my $MAXSECTORS = (20 * 1024 * 1024 * 2);
my $LVMSTRIPE = 6;

my $checksig = 1;
my $cleanonfail = 0;

my $os = `uname`;
chomp($os);
if ($os !~ /^(Linux|FreeBSD)$/) {
    die "Unknown OS '$os'\n";
}
my $arch = `uname -m`;
chomp($arch);
if ($arch !~ /^(x86_32|x86_64|aarch64|i386|amd64)$/) {
    die "Unknown arch '$arch'\n";
}
my $bindir = "/images/bin/${os}_${arch}";

foreach my $bin (@NEEDBINS) {
    if (! -x "$bindir/$bin") {
	die "Cannot find $bindir/$bin\n";
    }
}

if (@ARGV != 2) {
    print STDERR "Usage: testdelta.pl imageV1.ndz imageV2.ndz\n";
    exit(1);
}

my $uid = $>;
if ($uid == 0) {
    print STDERR "Do not run as root, script will sudo when necessary\n";
    exit(1);
}

my $tstamp = time();
my $logfile = "$LOGDIR/testdelta.$tstamp.log";
logit("Comparing '$ARGV[0]' and '$ARGV[1]'");
logit("Log is $logfile");

my %image1 = ( "name" => $ARGV[0] );
my %image2 = ( "name" => $ARGV[1] );

my $rv = 0;
$rv = phase1(\%image1, \%image2)
    if ($MAXPHASE > 0);
$rv = phase2(\%image1, \%image2)
    if ($rv == 0 && $MAXPHASE > 1);
$rv = phase3(\%image1, \%image2)
    if ($rv == 0 && $MAXPHASE > 2);

exit($rv);

#
# I. Basic:
#
# 1. create a shiny new delta image (imagedelta) I2.ddz.v2
# 2. create a shiny new full image (imageundelta) I2.ndz.v2 from I1 and delta
# 3. compare sigs of I2.ndz and I2.ndz.v2
#
sub phase1($$)
{
    my ($image1,$image2) = @_;
    my $fixedsig = 0;

    my $imagev1 = $image1->{'name'};
    my $imagev2 = $image2->{'name'};

    logit("START signature check of both images");
    if (sigcheck($imagev1) || sigcheck($imagev2)) {
	logit("FAILED signature check of both images");
	return 1;
    }
    logit("END signature check of both images");

    my $delta = $imagev2;
    $delta =~ s/ndz/ddz/;
    if ($imagev2 eq $delta) {
	logit("  $imagev2: malformed name, no .ndz");
	return 1;
    }

    logit("START image2 delta creation");
again:
    if (mysystem("$bindir/imagedelta -SVF $imagev1 $imagev2 $delta.new", 0)) {
	#
	# The verification pass of imagedelta requires that any hash range
	# falls completely in a single chunk or it has the magic high-bit
	# set in the chunk number. We apparently have some images where
	# the high bit is not properly set, triggering a verification failure.
	# To get around this, we regenerate the faulty signature file.
	#
	logit("  WARNING: could not generate delta image");
	if ($fixedsig < 2) {
	    my $nimage = ($fixedsig ? $imagev2 : $imagev1);

	    logit("  recreating signature for $nimage...");
	    mysystem("mv $nimage.sig $nimage.bak.sig");
	    if (!mysystem("$bindir/imagehash -qcX $nimage")) {
		logit("  validating new signature for $nimage...");
		if (!comparesigfiles("$nimage.bak", $nimage, 0)) {
		    unlink("$nimage.bak.sig");
		    logit("RESTART image2 delta creation");
		    $fixedsig++;
		    goto again;
		}
		unlink("$nimage.sig");
	    }
	    mysystem("mv $nimage.bak.sig $nimage.sig");
	}
	logit("FAILED image2 delta creation");
	return 1;
    }
    logit("END image2 delta creation");

    logit("START undelta to image2.new");
    if (mysystem("$bindir/imageundelta -SV $imagev1 $delta.new $imagev2.new")) {
	logit("FAILED undelta to image2.new");
	return 1;
    }
    logit("END undelta to image2.new");

    logit("START signature compare of image2 and image2.new");
    if (comparesigfiles($imagev2, "$imagev2.new", 1)) {
	logit("  $imagev2.new: signature mismatch with $imagev2");
	logit("FAILED signature compare of image2 and image2.new");
	return 1;
    }
    logit("END signature compare of image2 and image2.new");

    return 0;
}

#
# II. More advanced:
#
# 4. lay down I1.ndz on a ramdisk and optionally verify against sig
# 5. lay down I2.ndz on a ramdisk and optionally verify against sig
# 6. create an old school delta image (imagezip -D) I2.ddz from I2 disk, I1 sig
# 7. compare sigs of I2.ddz I2.ddz.v2
#
sub phase2($$)
{
    my ($image1,$image2) = @_;

    my $imagev1 = $image1->{'name'};
    my $imagev2 = $image2->{'name'};

    my $delta = $imagev2;
    $delta =~ s/ndz/ddz/;
    if ($imagev2 eq $delta) {
	logit("  $imagev2: malformed name, no .ndz");
	return 1;
    }

    logit("START unzip of image1");
    my ($devv1,$ssizev1) = unzipimage($imagev1);
    if (!$devv1) {
	logit("FAILED unzip of image1");
	return 1;
    }
    logit("END unzip of image1");

    if ($checksig) {
	logit("START signature check of image1 on disk");
	if (comparesigtodisk($imagev1, $devv1)) {
	    logit("FAILED signature check of image1 on disk");
	    unmakedisk($imagev1, $devv1) if ($cleanonfail);
	    return 1;
	}
	logit("END signature check of image1 on disk");
    }

    logit("START unzip of image2");
    my ($devv2,$ssizev2) = unzipimage($imagev2);
    if (!$devv2) {
	logit("FAILED unzip of image2");
	unmakedisk($imagev1, $devv1) if ($cleanonfail);
	return 1;
    }
    logit("END unzip of image2");

    if ($checksig) {
	logit("START signature check of image2 on disk");
	if (comparesigtodisk($imagev2, $devv2)) {
	    logit("FAILED signature check of image2 on disk");
	    unmakedisk($imagev2, $devv2) if ($cleanonfail);
	    unmakedisk($imagev1, $devv1) if ($cleanonfail);
	    return 1;
	}
	logit("END signature check of image2 on disk");
    }

    logit("START create imagezip delta of image2 from disk");
    if (zipimage($delta, "$imagev1.sig", $devv2, $ssizev2)) {
	logit("FAILED create imagezip delta of image2 from disk");
	unmakedisk($imagev2, $devv2) if ($cleanonfail);
	unmakedisk($imagev1, $devv1) if ($cleanonfail);
	return 1;
    }
    logit("END create imagezip delta of image2 from disk");

    #
    # Hashmaps for delta images produced by imagezip are less than
    # perfect as they can split a contiguous range in the new image if
    # the corresponding range in the old image was not fully populated
    # (and probably under other conditions too!)
    #
    if (-e "$delta.new") {
	logit("START image sigfile compare for deltas");
	# returns -1 if files are missing
	my $rv = comparesigfiles($delta, "$delta.new", 0);
	if ($rv > 0) {
	    logit("  WARNING: delta signature mismatch, ".
		  "comparing new sig with image");
	    $rv = comparesigtodisk("$delta.new", $devv2);
	    if ($rv) {
		logit("  *** $delta.new.sig is bad!");
	    }
	}
	if ($rv) {
	    logit("ERROR image sigfile compare for deltas");
	    unmakedisk($imagev2, $devv2) if ($cleanonfail);
	    unmakedisk($imagev1, $devv1) if ($cleanonfail);
	    return 1;
	}
	logit("END image sigfile compare for deltas");
    }

    $image1->{'disk'} = $devv1;
    $image2->{'disk'} = $devv2;
    $image1->{'disksize'} = $ssizev1;
    $image2->{'disksize'} = $ssizev2;

    return 0;
}

#
# III. Over the top:
#
# 8.  apply delta I2.ddz.v2 to I1 disk
# 9.  compare contents of I1 and I2 disks
# 10. load full I2.ndz.v2 image on I3 disk
# 11. compare contents of I2 and I3 disks
#
sub phase3($$)
{
    my ($image1,$image2) = @_;

    my $imagev1 = $image1->{'name'};
    my $devv1 = $image1->{'disk'};
    my $ssizev1 = $image1->{'disksize'};
    my $imagev2 = $image2->{'name'};
    my $devv2 = $image2->{'disk'};
    my $ssizev2 = $image2->{'disksize'};

    my $delta = $imagev2;
    $delta =~ s/ndz/ddz/;
    if ($imagev2 eq $delta) {
	logit("  $imagev2: malformed name, no .ndz");
	return 1;
    }

    logit("START unzip of delta.new onto image1 disk");

    if (applydelta("$delta.new", $devv1)) {
	logit("FAILED unzip of delta.new onto image1 disk");
	return 1;
    }
    logit("END unzip of delta.new onto image1 disk");

    logit("START clean zip of image1+delta disk");
    if (zipimage("$imagev2.fromdelta", undef, $devv1, $ssizev1, "-F 0 -x")) {
	logit("FAILED clean zip of image1+delta disk");
	return 1;
    }
    logit("END clean zip of image1+delta disk");

    logit("START clean zip of image2 disk");
    if (zipimage("$imagev2.fromold", undef, $devv2, $ssizev2, "-F 0 -x")) {
	logit("FAILED clean zip of image2 disk");
	return 1;
    }
    logit("END clean zip of image2 disk");

    logit("START compare image1+delta to image2 contents");
    if (compareimages("$imagev2.fromdelta", "$imagev2.fromold", 0)) {
	logit("FAILED compare image1+delta to image2 contents");
	return 1;
    }
    logit("END compare image1+delta to image2 contents");

    # done with image1 disk
    unlink("$imagev2.fromdelta", "$imagev2.fromdelta.sig");
    unmakedisk($imagev1, $devv1);

    logit("START unzip of image2.new");
    my $imagev3 = "$imagev2.new";
    my ($devv3,$ssizev3) = unzipimage($imagev3);
    if (!$devv3) {
	logit("FAILED unzip of image2.new");
	return 1;
    }
    logit("END unzip of image2.new");

    if ($checksig) {
	logit("START signature check of image2.new on disk");
	if (comparesigtodisk($imagev3, $devv3)) {
	    logit("FAILED signature check of image2.new on disk");
	    unmakedisk($imagev3, $devv3) if ($cleanonfail);
	    return 1;
	}
	logit("END signature check of image2.new on disk");
    }

    logit("START clean zip of image2.new disk");
    if (zipimage("$imagev2.clean", undef, $devv3, $ssizev3, "-F 0 -x")) {
	logit("FAILED clean zip of image2.new disk");
	return 1;
    }
    logit("END clean zip of image2.new disk");

    logit("START compare image2 to image2.new contents");
    if (compareimages("$imagev2.fromold", "$imagev2.clean", 0)) {
	logit("FAILED compare image2 to image2.new contents");
	return 1;
    }
    logit("END compare image2 to image2.new contents");

    # done with all disks
    unmakedisk($imagev2, $devv2);
    unlink("$imagev2.fromold", "$imagev2.fromold.sig");
    unmakedisk($imagev3, $devv3);

    return 0;
}

#
# Compare two images files.
#
# $how == 1: cmp the image files themselves (strongest)
# $how == 2: imageunzip -I the files, compare the streams
# $how == 4: dump and compare the signatures (weakest)
#
# $how == 0: try all three in order, return 0 if any succeed.
#
sub compareimages($$;$)
{
    my ($image1,$image2,$how) = @_;

    if (!$how || $how == 1) {
	if (!mysystem("cmp $image1 $image2")) {
	    return 0;
	}
	print "  WARNING: image file comparison fails, trying image stream\n"
	    if (!$how);
    }
    if (!$how || $how == 2) {
	if (!mysystem("$bindir/imageunzip -I $image1 - > $image1.raw") &&
	    !mysystem("$bindir/imageunzip -I $image2 - > $image2.raw") &&
	    !mysystem("cmp $image1.raw $image2.raw")) {
	    unlink("image1.raw", "image2.raw");
	    return 0;
	}
	unlink("image1.raw", "image2.raw");
	print "  WARNING: image stream comparison fails, trying image signature\n"
	    if (!$how);
    }
    if (!$how || $how == 3) {
	if (!comparesigfiles($image1, $image2, 0)) {
	    return 0;
	}
	print "  *** image signature comparison fails, images are not the same!\n"
	    if (!$how);
    }

    return 1;
}

sub sigcheck($)
{
    my $image = shift;

    if (! -e "$image") {
	print "  *** $image does not exist\n";
	return 1;
    }
    if (! -e "$image.sig") {
	print "  *** $image signature does not exist\n";
	return 1;
    }

    if ($checksig) {
	if (mysystem("$bindir/imagehash -qSX $image")) {
	    print "  *** $image signature did not check\n";
	    return 1;
	}

	# gen a new format sig file and compare
	if (mysystem("$bindir/imagehash -qcX -o ${image}foo.sig $image")) {
	    print "  *** could not generate signature for $image\n";
	    return 1;
	}
	if (comparesigfiles($image, "${image}foo", 1)) {
	    print "  *** new signature for $image does not match old\n";
	    return 1;
	}
    }

    return 0;
}

sub comparesigfiles($$$)
{
    my ($image1,$image2,$bitchnmoan) = @_;

    if (mysystem("$bindir/imagehash -RTq -o $image1.sig > $image1.sig.txt")) {
	print "  *** could not dump signature for $image1\n";
	return -1;
    }
    if (mysystem("$bindir/imagehash -RTq -o $image2.sig > $image2.sig.txt")) {
	print "  *** could not dump signature for $image2\n";
	return -1;
    }
    if (mysystem("diff -q $image1.sig.txt $image2.sig.txt", 1)) {
	if ($bitchnmoan) {
	    print "  *** signatures for $image1 and $image2 differ ".
		"(diff $image1.sig.txt $image2.sig.txt)\n";
	} else {
	    unlink("$image1.sig.txt", "$image2.sig.txt");
	}
	return 1;
    }

    unlink("$image1.sig.txt", "$image2.sig.txt");
    return 0;
}

sub comparesigtodisk($$)
{
    my ($image,$dev) = @_;

    if (mysystem("sudo $bindir/imagehash -q $image $dev", 1)) {
	#
	# XXX imagehash can fail if the image has relocations.
	#
	if (imagerelocs($image) == 0) {
	    print "  *** signature check of $image on $dev failed\n";
	    return 1;
	}
	print "  WARNING: signature check of $image on $dev failed,".
	    " probably due to relocations; continuing\n";
    }

    return 0;
}

sub zipimage($$$$;$)
{
    my ($image,$oldsig,$dev,$ssize,$moreargs) = @_;
    my $iargs;

    $iargs = "-U $image.sig";
    if ($oldsig) {
	$iargs .= " -H $oldsig";
    }

    #
    # XXX gak! Without an MBR/GPT, imagezip cannot (yet) figure out
    # what the filesystem is. We make a wild guess here based on image name.
    #
    my $ifile;
    if ($image =~ /([^\/]+)$/) {
	$ifile = $1;
    } else {
	$ifile = $image;
    }
    if ($ifile =~ /\+/) {
	# full image, don't need anything
	;
    } elsif ($image =~ /FBSD/) {
	# FreeBSD
	$iargs .= " -S 165 -c $ssize";
    } elsif ($ifile =~ /WIN/) {
	# WIN XP or 7 are full disk images
	;
    } else {
	# otherwise assume Linux
	$iargs .= " -S 131 -c $ssize";
    }

    if ($moreargs) {
	$iargs .= " $moreargs";
    }

    if (mysystem("sudo $bindir/imagezip $iargs $dev $image")) {
	print "  *** imagezip of $image to $dev failed\n";
	return 1;
    }

    # XXX
    mysystem("sudo chown $uid $image $image.sig");

    return 0;
}

sub unzipimage($)
{
    my $image = shift;
    my $dev = undef;

    # create a memdisk/LV for the image
    my $ssize = imagesize($image);
    my $dev = makedisk($image, $ssize);
    if (!$dev) {
	print "  *** could not create disk with $ssize sectors\n";
	return $dev;
    }
    # and load it
    if (mysystem("sudo $bindir/imageunzip -f $image $dev")) {
	print "  *** could not unzip $image to $dev\n";
	unmakedisk($image, $dev) if ($cleanonfail);
	return $dev;
    }

    # optionally compare vs signature

    return ($dev,$ssize);
}

sub applydelta($$)
{
    my ($delta,$dev) = @_;

    # load it
    if (mysystem("sudo $bindir/imageunzip -f $delta $dev")) {
	print "  *** could not unzip delta image $delta to $dev\n";
	return 1;
    }

    return 0;
}

sub imagesize($)
{
    my $image = shift;

    my @output = `$bindir/imagedump $image`;
    if ($?) {
	print "  *** could not get size of $image\n";
	return 0;
    }
    foreach my $line (@output) {
	chomp($line);
	if ($line =~ /covered sector range: \[(\d+)-(\d+)\]/) {
	    if ($1 != 0) {
		print "  WARNING: image does not start at 0\n";
	    }
	    $ssize = $2 + 1;
	    last;
	}
    }

    return $ssize;
}

sub imagerelocs($)
{
    my $image = shift;

    my @output = `$bindir/imagedump $image`;
    if ($?) {
	print "  *** could not get size of $image\n";
	return 0;
    }
    foreach my $line (@output) {
	chomp($line);
	if ($line =~ /(\d+) relocations covering/) {
	    return $1;
	}
    }

    return 0;
}

sub makedisk($$)
{
    my ($image,$ssize) = @_;
    my ($istr,$dev);

    if ($image =~ /([^\/]+)\/([^\/]+)$/) {
	$istr = "$1-$2";
    } elsif ($image =~ /([^\/]+)$/) {
	$istr = $1;
    } else {
	print "  *** could not parse name '$image'\n";
	return undef;
    }

    my $mb = int(($ssize + 2047) / 2048);
    $mb += 100;

    if ($os eq "Linux") {
	if ($ssize > $MAXSECTORS) {
	    print "  WARNING: image $image too large ($ssize) for ramdisk,".
		" using LV instead\n";
	    if (mysystem("sudo lvcreate -i $LVMSTRIPE -L ${mb}m -n $istr emulab")) {
		print "  *** could not create LV for $image\n";
		return undef;
	    }
	    return "/dev/emulab/$istr";
	}

	# XXX there has to be a better way!
	#
	# mount -t tmpfs -o size=20580m tmpfs /mnt/FOO.ndz
	# dd if=/dev/zero of=/mnt/FOO.ndz/disk bs=1024k seek=20479 count=1
	# losetup -f
	# losetup /dev/loop0 /mnt/FOO.ndz/disk
	#
	my $mountpoint = "/mnt/$istr";
	if (!mkdir($mountpoint)) {
	    print "  *** could not make mountpoint $mountpoint\n";
	    return undef;
	}
	if (mysystem("sudo mount -t tmpfs -o size=${mb}m tmpfs $mountpoint")) {
	    rmdir($mountpoint);
	    return undef;
	}
	my $mbm1 = $mb - 1;
	if (mysystem("sudo dd if=/dev/zero of=$mountpoint/disk bs=1024k seek=$mbm1 count=1")) {
	    mysystem("sudo umount $mountpoint");
	    rmdir($mountpoint);
	    return undef;
	}
	$dev = `sudo losetup -f`;
	chomp($dev);
	if (mysystem("sudo losetup $dev $mountpoint/disk")) {
	    mysystem("sudo umount $mountpoint");
	    rmdir($mountpoint);
	    return undef;
	}
    } else {
	print "  *** cannot do this under $os yet\n";
    }

    return $dev;
}

sub unmakedisk($$)
{
    my ($image,$dev) = @_;
    my $istr;

    if (!$image || !$dev) {
	return 0;
    }

    if ($image =~ /([^\/]+)\/([^\/]+)$/) {
	$istr = "$1-$2";
    } elsif ($image =~ /([^\/]+)$/) {
	$istr = $1;
    } else {
	print "  *** could not parse name '$image'\n";
	return undef;
    }

    if ($dev eq "/dev/emulab/$istr") {
	if (mysystem("sudo lvremove -f emulab/$istr")) {
	    print "  *** could not destroy LV emulab/$istr\n";
	    return -1;
	}
    } elsif (mysystem("sudo losetup -d $dev") ||
	     mysystem("sudo umount /mnt/$istr") ||
	     !rmdir("/mnt/$istr")) {
	print "  *** could not tear down ramdisk ($dev on /mnt/$istr)\n";
	return -1;
    }
    return 0;
}

sub mysystem($;$)
{
    my ($cmd,$quiet) = @_;
    my $now = localtime();
    my $redir;

    if (open(FD, ">>$logfile")) {
	print FD "==== $now: $cmd\n";
	close(FD);
    }

    if ($cmd =~ />/) {
	$redir = "2>>$logfile";
    } else {
	$redir = ">>$logfile 2>&1";
    }
    if (system("$cmd $redir")) {
	my $stat = $?;
	print "*** '$cmd' failed, see '$logfile'\n"
	    if (!$quiet);
	return $stat;
    }

    return 0;
}

sub logit($)
{
    my $msg = shift;
    my $pid = $$;

    my $elapsed = int(time() - $tstamp);
    printf "%05d: +%03d: %s\n", $pid, $elapsed, $msg;
}
