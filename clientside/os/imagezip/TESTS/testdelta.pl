#
# Given two full images I1 and I2:
#
# I. Basic:
#
# 1. create a shiny new delta image (imagedelta) I2.ddz.v2
# 2. create a shiny new full image (imageundelta) I2.ndz.v2 from I1 and delta
# 3. compare sigs of I2.ndz and I2.ndz.v2
#
# What we learn: imagedelta/undelta don't crash on the image in question,
# delta/undelta are correct at the level of the signature file.
#
# II. More advanced:
#
# 4. lay down I1.ndz on a ramdisk and optionally verify against sig
# 5. lay down I2.ndz on a ramdisk and optionally verify against sig
# 6. create an old school delta image (imagezip -D) I2.ddz from I2 disk, I1 sig
# 7. compare sigs of I2.ddz I2.ddz.v2
# 7a. if sigs don't compare [*], we compate I2.ddz.v2 against the I2 disk
#
# What we learn: imagezip and imagedelta delta creation are consistent.
#
# III. Over the top:
#
# 8.  apply delta I2.ddz.v2 to I1 disk
# 9.  compare contents of I1 and I2 disks [2]
# 10. load full I2.ndz.v2 image on I3 disk
# 11. compare contents of I2 and I3 disks [3]
#
# What we learn: new format files can be loaded (imagezip), actual on-disk
# contents are correct.
#
# Footnotes:
#
# [1] Since delta signatures generated by imagezip are imperfect,
#     the sigs may not match. To ensure their equivalence, we assume
#     the imagezip sig is correct and verify the other by checking it
#     against the on-disk image.
#
# [2] We cannot just "cmp" the two disks due to inexactness of the
#     delta created by imagedelta. It may include unused blocks that
#     will get propogate back to disk. Hence, we create new image files
#     from both disks using imagezip--with "-F 0" to ensure no free sects
#     are included--and byte compare those image files.
#
# [3] As with imagedelta, imageundelta is inexact and may have included
#     garbage sectors from the original image. We perform the same
#     comparison as in [2] instead.
#
my $TMPDIR = "/local/tmp";
my $LOGDIR = "/local/logs";
my @NEEDBINS = ("imagezip", "imageunzip", "imagehash", "imagedump",
    "imagedelta", "imageundelta");

my $MAXPHASE = 2;

my $MAXSECTORS = (20 * 1024 * 1024 * 2);
my $LVMSTRIPE = 6;

my $checksig = 0;
my $cleanonfail = 0;

my $os = `uname`;
chomp($os);
if ($os !~ /^(Linux|FreeBSD)$/) {
    die "Unknown OS '$os'\n";
}
my $arch = `uname -m`;
chomp($arch);
if ($arch !~ /^(x86_32|x86_64|aarch64|i386|amd64)$/) {
    die "Unknown arch '$arch'\n";
}
my $bindir = "/images/bin/${os}_${arch}";

foreach my $bin (@NEEDBINS) {
    if (! -x "$bindir/$bin") {
	die "Cannot find $bindir/$bin\n";
    }
}

if (@ARGV != 2) {
    print STDERR "Usage: testdelta.pl imageV1.ndz imageV2.ndz\n";
    exit(1);
}

my $uid = $>;
if ($uid == 0) {
    print STDERR "Do not run as root, script will sudo when necessary\n";
    exit(1);
}

my $tstamp = time();
print "Logs will be $LOGDIR/$tstamp.*.log ...\n";

my %image1 = ( "name" => $ARGV[0] );
my %image2 = ( "name" => $ARGV[1] );

my $rv = 0;
$rv = phase1(\%image1, \%image2)
    if ($MAXPHASE > 0);
$rv = phase2(\%image1, \%image2)
    if ($rv == 0 && $MAXPHASE > 1);
$rv = phase3(\%image1, \%image2)
    if ($rv == 0 && $MAXPHASE > 2);

if ($rv == 0) {
    unmakedisk($image1{'name'}, $image1{'disk'});
    unmakedisk($image2{'name'}, $image2{'disk'});
}

exit($rv);

#
# I. Basic:
#
# 1. create a shiny new delta image (imagedelta) I2.ddz.v2
# 2. create a shiny new full image (imageundelta) I2.ndz.v2 from I1 and delta
# 3. compare sigs of I2.ndz and I2.ndz.v2
#
sub phase1($$)
{
    my ($image1,$image2) = @_;
    my $fixedsig = 0;

    my $imagev1 = $image1->{'name'};
    my $imagev2 = $image2->{'name'};

    logit("START signature check of both images");
    if (sigcheck($imagev1) || sigcheck($imagev2)) {
	logit("FAILED signature check of both images");
	return 1;
    }
    logit("END signature check of both images");

    my $delta = $imagev2;
    $delta =~ s/ndz/ddz/;
    if ($imagev2 eq $delta) {
	logit("  $imagev2: malformed name, no .ndz");
	return 1;
    }

    logit("START image2 delta creation");
again:
    if (mysystem("$bindir/imagedelta -SVF $imagev1 $imagev2 $delta.new", 0)) {
	logit("  WARNING: could not generate delta image");
	if (!$fixedsig) {
	    logit("  recreating signature for $imagev2...");
	    mysystem("mv $imagev2.sig $imagev2.bak.sig");
	    if (!mysystem("$bindir/imagehash -qcX $imagev2")) {
		logit("  validating new signature for $imagev2...");
		if (!comparesigfiles("$imagev2.bak", $imagev2, 0)) {
		    unlink("$imagev2.bak.sig");
		    logit("RESTART image2 delta creation");
		    $fixedsig = 1;
		    goto again;
		}
		unlink("$imagev2.sig");
	    }
	    mysystem("mv $imagev2.bak.sig $imagev2.sig");
	}
	logit("FAILED image2 delta creation");
	return 1;
    }
    logit("END image2 delta creation");

    logit("START undelta to image2.new");
    if (mysystem("$bindir/imageundelta -SV $imagev1 $delta.new $imagev2.new")) {
	logit("FAILED undelta to image2.new");
	return 1;
    }
    logit("END undelta to image2.new");

    logit("START signature compare of image2 and image2.new");
    if (comparesigfiles($imagev2, "$imagev2.new", 1)) {
	logit("  $imagev2.new: signature mismatch with $imagev2");
	logit("FAILED signature compare of image2 and image2.new");
	return 1;
    }
    logit("END signature compare of image2 and image2.new");

    return 0;
}

#
# II. More advanced:
#
# 4. lay down I1.ndz on a ramdisk and optionally verify against sig
# 5. lay down I2.ndz on a ramdisk and optionally verify against sig
# 6. create an old school delta image (imagezip -D) I2.ddz from I2 disk, I1 sig
# 7. compare sigs of I2.ddz I2.ddz.v2
#
sub phase2($$)
{
    my ($image1,$image2) = @_;

    my $imagev1 = $image1->{'name'};
    my $imagev2 = $image2->{'name'};

    my $delta = $imagev2;
    $delta =~ s/ndz/ddz/;
    if ($imagev2 eq $delta) {
	logit("  $imagev2: malformed name, no .ndz");
	return 1;
    }

    logit("START unzip of image1");
    my ($devv1,$ssizev1) = unzipimage($imagev1);
    if (!$devv1) {
	logit("FAILED unzip of image1");
	return 1;
    }
    logit("END unzip of image1");

    logit("START signature check of image1 on disk");
    if ($checksig) {
	if (mysystem("$bindir/imagehash -qX $imagev1 $devv1")) {
	    logit("FAILED signature check of image1 on disk");
	    unmakedisk($imagev1, $devv1) if ($cleanonfail);
	    return 1;
	}
    }
    logit("END signature check of image1 on disk");

    logit("START unzip of image2");
    my ($devv2,$ssizev2) = unzipimage($imagev2);
    if (!$devv2) {
	logit("FAILED unzip of image2");
	unmakedisk($imagev1, $devv1) if ($cleanonfail);
	return 1;
    }
    logit("END unzip of image2");

    logit("START signature check of image2 on disk");
    if ($checksig) {
	if (mysystem("$bindir/imagehash -qX $imagev2 $devv2")) {
	    logit("FAILED signature check of image2 on disk");
	    unmakedisk($imagev2, $devv2) if ($cleanonfail);
	    unmakedisk($imagev1, $devv1) if ($cleanonfail);
	    return 1;
	}
    }
    logit("END signature check of image2 on disk");

    logit("START create delta of image2 from disk with imagezip");
    if (zipimage("$delta.old", "$imagev1.sig", $devv2, $ssizev2)) {
	logit("FAILED create delta of image2 from disk with imagezip");
	unmakedisk($imagev2, $devv2) if ($cleanonfail);
	unmakedisk($imagev1, $devv1) if ($cleanonfail);
	return 1;
    }
    logit("END create delta of image2 from disk with imagezip");

    #
    # Hashmaps for delta images produced by imagezip are less than
    # perfect as they can split a contiguous range in the new image if
    # the corresponding range in the old image was not fully populated
    # (and probably under other conditions too!)
    #
    if (-e "$delta.new") {
	logit("START image sigfile compare for deltas");
	# returns -1 if files are missing
	my $rv = comparesigfiles("$delta.old", "$delta.new", 0);
	if ($rv > 0) {
	    logit("  WARNING: delta signature mismatch, ".
		  "comparing new sig with image");
	    $rv = mysystem("$bindir/imagehash -q -o $delta.new.sig $devv2");
	    if ($rv) {
		logit("  *** $delta.new.sig is bad!");
	    }
	}
	if ($rv) {
	    logit("ERROR image sigfile compare for deltas");
	    unmakedisk($imagev2, $devv2) if ($cleanonfail);
	    unmakedisk($imagev1, $devv1) if ($cleanonfail);
	    return 1;
	}
	logit("END image sigfile compare for deltas");
    }

    unlink("$delta.old", "$delta.old.sig");

    $image1->{'disk'} = $devv1;
    $image2->{'disk'} = $devv2;
    $image1->{'disksize'} = $ssizev1;
    $image2->{'disksize'} = $ssizev2;

    return 0;
}

#
# III. Over the top:
#
# 8.  apply delta I2.ddz.v2 to I1 disk
# 9.  compare contents of I1 and I2 disks
# 10. load full I2.ndz.v2 image on I3 disk
# 11. compare contents of I2 and I3 disks
#
sub phase3($$)
{
    my ($image1,$image2) = @_;

    my $imagev1 = $image1->{'name'};
    my $devv1 = $image1->{'disk'};
    my $ssizev1 = $image1->{'disksize'};
    my $imagev2 = $image2->{'name'};
    my $devv2 = $image2->{'disk'};
    my $ssizev2 = $image2->{'disksize'};

    my $delta = $imagev2;
    $delta =~ s/ndz/ddz/;
    if ($imagev2 eq $delta) {
	logit("  $imagev2: malformed name, no .ndz");
	return 1;
    }

    logit("START unzip of delta.new to image1");

    if (applydelta($imagev1, $devv1)) {
	logit("FAILED unzip of delta.new to image1");
	return 1;
    }
    logit("END unzip of delta.new to image1");

    return 0;
}

sub comparesigfiles($$$)
{
    my ($image1,$image2,$bitchnmoan) = @_;

    if (mysystem("$bindir/imagehash -RTq -o $image1.sig > $image1.sig.txt")) {
	print "$image1: could not dump signature\n";
	return -1;
    }
    if (mysystem("$bindir/imagehash -RTq -o $image2.sig > $image2.sig.txt")) {
	print "$image2: could not dump signature\n";
	return -1;
    }
    if (mysystem("diff -q $image1.sig.txt $image2.sig.txt", 1)) {
	print "*** signatures differ (diff $image1.sig.txt $image2.sig.txt)\n"
	    if ($bitchnmoan);
	return 1;
    }

    unlink("$image1.sig.txt", "$image2.sig.txt");
    return 0;
}

sub sigcheck($)
{
    my $image = shift;

    if (! -e "$image") {
	print STDERR "$image: does not exist\n";
	return 1;
    }
    if (! -e "$image.sig") {
	print STDERR "$image: signature does not exist\n";
	return 1;
    }

    if ($checksig) {
	if (mysystem("$bindir/imagehash -qSX $image")) {
	    print "$image: signature did not check\n";
	    return 1;
	}

	# gen a new format sig file and compare
	if (mysystem("$bindir/imagehash -qcX -o ${image}foo.sig $image")) {
	    print "$image: could not generate signature\n";
	    return 1;
	}
	if (comparesigfiles($image, "${image}foo", 1)) {
	    print "$image: new signature does not match old\n";
	    return 1;
	}
    }

    return 0;
}

sub zipimage($$$$)
{
    my ($image,$oldsig,$dev,$ssize) = @_;
    my $iargs;

    $iargs = "-U $image.sig";
    if ($oldsig) {
	$iargs .= " -H $oldsig";
    }

    #
    # XXX gak! Without an MBR/GPT, imagezip cannot (yet) figure out
    # what the filesystem is. We make a wild guess here based on image name.
    #
    my $ifile;
    if ($image =~ /([^\/]+)$/) {
	$ifile = $1;
    } else {
	$ifile = $image;
    }
    if ($ifile =~ /\+/) {
	# full image, don't need anything
	;
    } elsif ($image =~ /FBSD/) {
	# FreeBSD
	$iargs .= " -S 165 -c $ssize";
    } elsif ($ifile =~ /WIN/) {
	# WIN XP or 7 are full disk images
	;
    } else {
	# otherwise assume Linux
	$iargs .= " -S 131 -c $ssize";
    }

    if (mysystem("sudo $bindir/imagezip $iargs $dev $image")) {
	print "$image: imagezip failed\n";
	return 1;
    }

    # XXX
    mysystem("sudo chown $uid $image $image.sig");

    return 0;
}

sub unzipimage($)
{
    my $image = shift;
    my $dev = undef;

    # create a memdisk/LV for the image
    my $ssize = imagesize($image);
    my $dev = makedisk($image, $ssize);
    if (!$dev) {
	print "$image: could not create disk with $ssize sectors\n";
	return $dev;
    }
    # and load it
    if (mysystem("sudo $bindir/imageunzip -f $image $dev")) {
	print "$image: could not unzip image to $dev\n";
	unmakedisk($image, $dev) if ($cleanonfail);
	return $dev;
    }

    return ($dev,$ssize);
}

sub applydelta($$)
{
    my ($delta,$dev) = @_;

    # load it
    if (mysystem("sudo $bindir/imageunzip -f $delta $dev")) {
	print "$image: could not unzip delta image to $dev\n";
	return 1;
    }

    return 0;
}

sub imagesize($)
{
    my $image = shift;

    my @output = `$bindir/imagedump $image`;
    if ($?) {
	print "$image: *** could not get size of image\n";
	return 0;
    }
    foreach my $line (@output) {
	chomp($line);
	if ($line =~ /covered sector range: \[(\d+)-(\d+)\]/) {
	    if ($1 != 0) {
		print "$image: WARNING: image does not start at 0\n";
	    }
	    $ssize = $2 + 1;
	    last;
	}
    }

    return $ssize;
}

sub makedisk($$)
{
    my ($image,$ssize) = @_;
    my ($istr,$dev);

    if ($image =~ /([^\/]+)\/([^\/]+)$/) {
	$istr = "$1-$2";
    } elsif ($image =~ /([^\/]+)$/) {
	$istr = $1;
    } else {
	print "$image: *** could not parse '$image'\n";
	return undef;
    }

    my $mb = int(($ssize + 2047) / 2048);
    $mb += 100;

    if ($os eq "Linux") {
	if ($ssize > $MAXSECTORS) {
	    print "$image: ERROR: image too large ($ssize) for ramdisk,".
		" using LV instead\n";
	    if (mysystem("sudo lvcreate -i $LVMSTRIPE -L ${mb}m -n $istr emulab")) {
		print STDERR "could not create LV\n";
		return undef;
	    }
	    return "/dev/emulab/$istr";
	}

	# XXX there has to be a better way!
	#
	# mount -t tmpfs -o size=20580m tmpfs /mnt/FOO.ndz
	# dd if=/dev/zero of=/mnt/FOO.ndz/disk bs=1024k seek=20479 count=1
	# losetup -f
	# losetup /dev/loop0 /mnt/FOO.ndz/disk
	#
	my $mountpoint = "/mnt/$istr";
	if (!mkdir($mountpoint)) {
	    print STDERR "could not make mountpoint $mountpoint\n";
	    return undef;
	}
	if (mysystem("sudo mount -t tmpfs -o size=${mb}m tmpfs $mountpoint")) {
	    rmdir($mountpoint);
	    return undef;
	}
	my $mbm1 = $mb - 1;
	if (mysystem("sudo dd if=/dev/zero of=$mountpoint/disk bs=1024k seek=$mbm1 count=1")) {
	    mysystem("sudo umount $mountpoint");
	    rmdir($mountpoint);
	    return undef;
	}
	$dev = `sudo losetup -f`;
	chomp($dev);
	if (mysystem("sudo losetup $dev $mountpoint/disk")) {
	    mysystem("sudo umount $mountpoint");
	    rmdir($mountpoint);
	    return undef;
	}
    } else {
	print STDERR "Cannot do this under $os yet\n";
    }

    return $dev;
}

sub unmakedisk($$)
{
    my ($image,$dev) = @_;
    my $istr;

    if (!$image || !$dev) {
	return 0;
    }

    if ($image =~ /([^\/]+)\/([^\/]+)$/) {
	$istr = "$1-$2";
    } elsif ($image =~ /([^\/]+)$/) {
	$istr = $1;
    } else {
	print "$image: *** could not parse '$image'\n";
	return undef;
    }

    if ($dev eq "/dev/emulab/$istr") {
	if (mysystem("sudo lvremove -f emulab/$istr")) {
	    print STDERR "$image: could not destroy LV\n";
	    return -1;
	}
    } elsif (mysystem("sudo losetup -d $dev") ||
	     mysystem("sudo umount /mnt/$istr") ||
	     !rmdir("/mnt/$istr")) {
	print STDERR "$image: could not tear down ramdisk\n";
	return -1;
    }
    return 0;
}

sub mysystem($;$)
{
    my ($cmd,$quiet) = @_;
    my $logfile = "$LOGDIR/testdelta.$tstamp.log";
    my $now = localtime();
    my $redir;

    if (open(FD, ">>$logfile")) {
	print FD "==== $now: $cmd\n";
	close(FD);
    }

    if ($cmd =~ />/) {
	$redir = "2>>$logfile";
    } else {
	$redir = ">>$logfile 2>&1";
    }
    if (system("$cmd $redir")) {
	my $stat = $?;
	print STDERR "*** '$cmd' failed, see '$logfile'\n"
	    if (!$quiet);
	return $stat;
    }

    return 0;
}

sub logit($)
{
    my $msg = shift;

    my $elapsed = int(time() - $tstamp);
    printf "+%03d: %s\n", $elapsed, $msg;
}
