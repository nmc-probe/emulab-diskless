<?php
#
# Copyright (c) 2000-2014 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
chdir("..");
include_once("geni_defs.php");
chdir("apt");

#
# 
#
function Do_CreateSecret()
{
    global $ajax_args;
    global $TBDIR;

    #
    # Destroy any existing session data to prevent replay.
    #
    if (!(session_start() &&
	  session_destroy())) {
	SPITAJAX_ERROR(-1, "Internal session error 1");
	return;
    }
    session_commit();
    if (!session_start()) {
	SPITAJAX_ERROR(-1, "Internal session error 2");
	return;
    }
    
    if (!isset($ajax_args["certificate"])) {
	SPITAJAX_ERROR(1, "Missing user public key");
	return;
    }
    $certificate = $ajax_args["certificate"];

    if (!isset($ajax_args["r1_encrypted"])) {
	SPITAJAX_ERROR(1, "Missing encrypted random string");
	return;
    }
    $r1_encrypted = $ajax_args["r1_encrypted"];
    $r2_decrypted = GENHASH();

    $infname  = tempnam("/tmp", "pkcs7in");
    $outfname = tempnam("/tmp", "pkcs7out");
    $userCertName = tempnam("/tmp", "pkcs7cert");

    #
    # Decrypt the random bytes. To do this we have to put the stuff
    # into a file, and it is decrypted into a file which we have to read.
    #
    $fp = fopen($infname, "w");
    fwrite($fp, $r1_encrypted);
    fclose($fp);
    $exec_output_array = array();
    $exec_retval       = 0;

    exec("/usr/bin/openssl smime -decrypt -inform PEM -inkey ".
	 "${TBDIR}/etc/genisa.pem -in $infname -out $outfname",
	 $exec_output_array, $exec_retval);

    if ($exec_retval) {
	$exec_output = "";
	for ($i = 0; $i < count($exec_output_array); $i++) {
	    $exec_output .= "$exec_output_array[$i]\n";
	}
	TBERROR("Could not decrypt pkcs7 data:\n\n$exec_output", 0);
	SPITAJAX_ERROR(-1, "Internal Error");
	return;
    }
    $r1_decrypted = file_get_contents($outfname);
    $r1_decrypted = rtrim($r1_decrypted);

    #
    # Now encrypt the random bytes.
    #
    $fp = fopen($infname, "w");
    fwrite($fp, $r2_decrypted);
    fclose($fp);

    $fp = fopen($userCertName, "w");
    fwrite($fp, $certificate);
    fclose($fp);

    exec("/usr/bin/openssl smime -encrypt -outform PEM ".
	 "-in $infname -out $outfname -aes256 $userCertName",
	 $exec_output_array, $exec_retval);

    if ($exec_retval) {
	$exec_output = "";
	for ($i = 0; $i < count($exec_output_array); $i++) {
	    $exec_output .= "$exec_output_array[$i]\n";
	}
	TBERROR("Could not encrypt random string:\n\n$exec_output", 0);
	SPITAJAX_ERROR(-1, "Internal Error");
	return;
    }
    $r2_encrypted = file_get_contents($outfname);
    $secret = $r1_decrypted . $r2_decrypted;#bin2hex(pack('H*', $r1_decrypted) ^ pack('H*', $r2_decrypted));

    $blob = array();
    $blob["r2_encrypted"] = $r2_encrypted;

    # Store in the session.
    $_SESSION["secret"] = $secret;
    $_SESSION["certificate"]  = $certificate;
    session_commit();

    unlink($infname);
    unlink($outfname);
    SPITAJAX_RESPONSE($blob);
}

#
# 
#
function Do_VerifySpeaksfor()
{
    global $ajax_args;
    global $TBDIR;
    global $TBAUTHCOOKIE, $TBLOGINCOOKIE, $TBAUTHTIMEOUT;

    # Restore the session.
    if (!session_start()) {
	SPITAJAX_ERROR(-1, "Internal session error 3");
	return;
    }

    if (!isset($ajax_args["speaksfor"]) || $ajax_args["speaksfor"] == "") {
	SPITAJAX_ERROR(1, "Missing speaksfor credential");
	session_destroy();
	return;
    }
    $speaksfor = $ajax_args["speaksfor"];

    if (!isset($ajax_args["signature"]) || $ajax_args["signature"] == "") {
	SPITAJAX_ERROR(1, "Missing signature for the credential");
	session_destroy();
	return;
    }
    $signature = $ajax_args["signature"];

    if (!isset($_SESSION["secret"]) || $_SESSION["secret"] == "") {
	SPITAJAX_ERROR(1, "What is your secret?");
	session_destroy();
	return;
    }

    #
    # Really the SHA256(speaksfor + secret). We need to verify that.
    #
    $secret = $_SESSION["secret"];
    $hash   = hash("sha256", $speaksfor . $secret);
    if ($hash != $signature) {
	SPITAJAX_ERROR(1, "Bad signature on credential");
	session_destroy();
	return;
    }

    $infname  = tempnam("/tmp", "certin");
    $outfname = tempnam("/tmp", "certout");

    #
    # The certificate belongs to the user and tells us who it is via
    # the URN. Use external script to parse the certificate and tell
    # us whats in it. We get back some simple XML.
    #
    $fp = fopen($infname, "w");
    fwrite($fp, $_SESSION["certificate"]);
    fclose($fp);
    $exec_output_array = array();
    $exec_retval       = 0;
    $exec_output       = "";

    exec("$TBDIR/sbin/protogeni/parsecert $infname $outfname",
	 $exec_output_array, $exec_retval);

    if ($exec_retval) {
	$exec_output = "";
	for ($i = 0; $i < count($exec_output_array); $i++) {
	    $exec_output .= "$exec_output_array[$i]\n";
	}
	TBERROR("Could not parse user certificate:\n\n$exec_output", 0);
	SPITAJAX_ERROR(-1, "Internal Error");
	return;
    }
    $parse_output = file_get_contents($outfname);
    unlink($infname);
    unlink($outfname);

    #
    # Decode simple XML that is returned. 
    #
    $parsed = simplexml_load_string($parse_output);
    if (!$parsed) {
	TBERROR("Could not parse XML output:\n$parse_output\n", 0);
	SPITAJAX_ERROR(-1, "Internal Error");
	return;
    }
    $info = array();
    foreach ($parsed->attribute as $attribute) {
	$info[(string)$attribute['name']] = (string)$attribute;
    }

    #
    # Find the user and log them in, returning the cookies to the caller.
    #
    $this_user = User::LookupByUUID($info["uuid"]);
    if (!$this_user) {
	SPITAJAX_ERROR(1, "Could not find local user account");
	session_destroy();
	return;
    }
    list ($loginhash, $logincrc) =
	DOLOGIN_MAGIC($this_user->uid(), $this_user->uid_idx(), null, 0, 1);
    if (! ($loginhash && $logincrc)) {
	SPITAJAX_ERROR(1, "Could not log you in. Sorry!");
	session_destroy();
	return;
    }
    $blob = array();
    $blob["hashname"]  = $TBAUTHCOOKIE;
    $blob["hash"]      = $loginhash;
    $blob["loginname"] = $logincrc;
    $blob["login"]     = $TBLOGINCOOKIE;
    $blob["timeout"]   = $TBAUTHTIMEOUT;
    session_destroy();
    SPITAJAX_RESPONSE($blob);
}

#
# Create a new user. All we have is the email, urn, and uuid.
#
function CreateNonLocalUser($urn, $email, $cert, $cred)
{
    #
    # 
    #
}

# Local Variables:
# mode:php
# End:
?>
