<?php
#
# Copyright (c) 2000-2015 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
chdir("..");
include_once("webtask.php");
chdir("apt");
include_once("profile_defs.php");
include_once("instance_defs.php");

#
# Return info about specific profile.
#
function Do_GetProfile()
{
    global $this_user;
    global $ajax_args;
    global $DEFAULT_AGGREGATE;
    
    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    $uuid = $ajax_args["uuid"];
    if (!IsValidUUID($uuid)) {
	SPITAJAX_ERROR(1, "Not a valid UUID: $uuid");
	return;
    }
    $profile = Profile::Lookup($uuid);
    if (!$profile) {
	SPITAJAX_ERROR(1, "No such profile $uuid");
	return;
    }
    $amdefault = $DEFAULT_AGGREGATE;
    # Temporary override until constraint system in place.
    if ($profile->BestAggregate()) {
	$amdefault = $profile->BestAggregate();
    }
    $ispp = ($profile->isParameterized() ? 1 : 0);
    
    #
    # Knowing the UUID means the user can instantiate it,
    # so no permission checks on the profile. 
    #
    SPITAJAX_RESPONSE(array('rspec'       => $profile->rspec(),
			    'name'        => $profile->name(),
			    'ispprofile'  => $ispp,
			    'amdefault'   => $amdefault));
}

#
# Return parameter form fragment and default values.
#
function Do_GetParameters()
{
    global $this_user;
    global $ajax_args;
    global $suexec_output, $suexec_output_array;

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    $profile = Profile::Lookup($ajax_args["uuid"]);
    if (!$profile) {
	SPITAJAX_ERROR(1, "Unknown profile uuid");
	return;
    }
    if (!isset($this_user)) {
	if (!$profile->ispublic()) {
	    SPITAJAX_ERROR(1, "Not enough permission to instantiate profile");
	    return;
	}	    
    }
    elseif (!$profile->CanInstantiate($this_user)) {
	SPITAJAX_ERROR(1, "Not enough permission to instantiate profile");
	return;
    }
    if (!$profile->isParameterized()) {
	SPITAJAX_ERROR(1, "Not a parameterized profile");
	return;
    }
    list ($formfrag, $defaults) = $profile->GenerateFormFragment();
    SPITAJAX_RESPONSE(array("formfrag" => htmlentities($formfrag),
			    "defaults" => $defaults));
}

#
# Instantiate profile (as the user)
#
function Do_Instantiate()
{
    global $this_user, $DEFAULT_AGGREGATE, $ISCLOUD;
    global $ajax_args;
    $am_array = Instance::DefaultAggregateList();
    
    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    $profile = Profile::Lookup($ajax_args["uuid"]);
    if (!$profile) {
	SPITAJAX_ERROR(1, "Unknown profile uuid");
	return;
    }
    if (!isset($this_user)) {
	if (!$profile->ispublic()) {
	    SPITAJAX_ERROR(1, "Not enough permission to instantiate profile");
	    return;
	}	    
    }
    elseif (!$profile->CanInstantiate($this_user)) {
	SPITAJAX_ERROR(1, "Not enough permission to instantiate profile");
	return;
    }
    $args = array();
    $args["username"]   = $this_user->uid();
    $args["email"]      = $this_user->email();
    $args["profile"]    = $profile->uuid();
    # Guest users not allowed to provide rspec
    if (isset($this_user) &&
        array_key_exists("rspec", $ajax_args)) {
	$args["rspec"]  = $ajax_args["rspec"];
    }
    $opts = "";
    # Guest users not allowed to choose aggregate.
    if (isset($this_user) && ($ISCLOUD || ISADMIN() || STUDLY()) &&
	isset($ajax_args["where"])) {
	if (array_key_exists($ajax_args["where"], $am_array)) {
	    $opts = "-a " . $am_array[$ajax_args["where"]];
	}
	else {
	    SPITAJAX_ERROR(1, "Invalid Aggregate");
	    return;
	}
    }
    else {
	# Temporary until constraint system in place.
	$best = $profile->BestAggregate();
	if (!$best) {
	    $best = $DEFAULT_AGGREGATE;
	}
	$opts = "-a " . $am_array[$best];
    }

    #
    # Invoke the backend.
    #
    $errors = array();
    list ($instance, $creator) =
	Instance::Instantiate($this_user, $opts, $args, $errors);

    if (!isset($instance) || is_null($instance)) {
	SPITAJAX_ERROR(1, $errors["error"]);
        return;
    }
    #
    # Redirect user to status page.
    #
    $uuid = $instance->uuid();
    SPITAJAX_RESPONSE("status.php?uuid=$uuid");
}

#
# Return constraint info for a set of images.
#
function Do_GetImageInfo()
{
    global $this_user;
    global $ajax_args;

    if (!isset($ajax_args["images"])) {
	SPITAJAX_ERROR(1, "Missing image list");
	return;
    }
    if ($this_user && !$this_user->webonly()) {
        if (!isset($ajax_args["project"])) {
            SPITAJAX_ERROR(1, "Missing project selection");
            return;
        }
        $pid = $ajax_args["project"];
        if (!preg_match("/^[-\w]+$/", $pid)) {
            SPITAJAX_ERROR(1, "Illegal project name: $pid");
            return;
        }
        $project = Project::Lookup($pid);
        if (!$project) {
            SPITAJAX_ERROR(1, "No such project: $pid");
            return;
        }
        $approved = 0;
        if (! (ISADMIN() ||
               ($project->IsMember($this_user, $approved) && $approved))) {
            SPITAJAX_ERROR(1, "Not a member of project: $pid");
            return;
        }
    }
    $dblink = DBConnect("ims");

    $constraints = array();
    $images      = array();

    foreach ($ajax_args["images"] as $urn) {
        $types = array();
        $virts = array();
        
        if (Instance::ValidURN($urn)) {
            # This // vs : thing is a pain.
            $urn = preg_replace('/\/\//', ":", $urn);
            # Need to see if there is a specific version.
            list ($auth,$type,$id) = Instance::ParseURN($urn);
            list ($proj,$name,$version) = preg_split('/:/', $id);

            #
            # Lookup is without the version number in the urn.
            #
            $urn = preg_replace('/:\d+$/', "", $urn);
            $safe_urn = addslashes($urn);

         again:
            if (is_null($version)) {
                if ($proj == "emulab-ops") {
                    list ($a,$b,$c) = Instance::ParseURN($urn);
                    $safe_urn = addslashes("urn:publicid:IDN+%+image+${c}");
                    $innerclause = "urn like '$safe_urn'";
                }
                else {
                    $innerclause = "urn='$safe_urn'";
                }
                $query_result =
                    DBQueryFatal("select i.*,v.* from image_versions as v ".
                                 "   inner join ".
                                 "      (select urn,max(version) as version ".
                                 "         from image_versions ".
                                 "       where $innerclause ".
                                 "       group by urn) as ij ".
                                 "   on v.urn=ij.urn and v.version=ij.version ".
                                 "left join images as i on i.urn=v.urn",
                                $dblink);
            }
            else {
                $query_result =
                    DBQueryFatal("select i.*,v.* from image_versions as v ".
                                "left join images as i on ".
                                "     i.image_uuid=v.image_uuid ".
                                "where v.urn='$safe_urn' and v.version='$version'",
                                $dblink);
            }
        }
        elseif (parse_url($urn)) {
            #
            # Or it must be a URL.
            #
            $safe_url = addslashes($urn);

            $query_result = 
                DBQueryWarn("select i.*,v.* from image_versions as v ".
                            "left join images as i on ".
                            "     i.image_uuid=v.image_uuid ".
                            "where v.metadata_url='$safe_url'",
                            $dblink);
        }
        else {
            continue;
        }
        if (!$query_result || !mysql_num_rows($query_result)) {
            # Is this the right thing to do?
            continue;
        }
        while ($row = mysql_fetch_array($query_result)) {
            #
            # Need to look at the privacy setting, and if the image is not
            # public, the user has to be in the same project as the image
            # (or own the image), or it has to be listed in the permissions.
            #
            if ($row["visibility"] != "public") {
                # This will not be set for guests.
                if (!isset($project)) {
                    continue;
                }
            
                #
                # Project selection box has to match the project the image
                # belongs too. If the user changes the project selection, we
                # have to rerun the constraints.
                #
                list ($auth) = Instance::ParseURN($row["project_urn"]);
                list ($domain,$impid) = preg_split('/:/', $auth);
                if ($impid && $impid == $pid) {
                    goto allowed;
                }

                #
                # Check special permissions.
                #
                $perms_result =
                    DBQueryWarn("select * from image_permissions ".
                                "where urn='" . addslashes($row["urn"]) . "'",
                                $dblink);

                while ($prow = mysql_fetch_array($perms_result)) {
                    $ptype = $prow["permission_type"];
                    $purn  = $prow["permission_urn"];
                    
                    if ($ptype == "user") {
                        list ($ign1,$ign2,$id) = Instance::ParseURN($purn);
                        if ($id && $id == $this_user->uid()) {
                            goto allowed;
                        }
                    }
                    elseif ($ptype == "project") {
                        list ($auth) = Instance::ParseURN($purn);
                        list ($domain,$ppid) = preg_split('/:/', $auth);
                        if ($ppid && $ppid == $pid) {
                            goto allowed;
                        }
                    }
                }
                continue;
            }
     allowed:
	    foreach (preg_split("/,/", $row["types_known_working"]) as $type) {
                $types[$type] = $type;
	    }
            $virts[$row["virtualizaton"]] = $row["virtualizaton"];
            $description = $row["description"];
        }
        if (count($types)) {
            # These are reversed from what they should mean!
            $typelist = implode(",", array_keys($types));
            $virtlist = implode(",", array_keys($virts));

            $constraints[] =
                array("node" =>
                      array("images" => array($urn),
                            "types"  => array($virtlist)));
            $constraints[] =
                array("node" =>
                      array("images"   => array($urn),
                            "hardware" => array($typelist)));

            $images[] = array("id"   => $urn,
                              "name" => $description);
        }
    }
    $result = array(array("constraints" => $constraints,
                          "images" => $images));
    
    SPITAJAX_RESPONSE($result);
}

# Local Variables:
# mode:php
# End:
?>
