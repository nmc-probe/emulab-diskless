#!/usr/bin/perl -w

#
# gitmaild - simple gitmail wrapper for use with gitlab
# Note: *must* be run on the same host, and have permission to read the
# git repos in gitlab's home
# TODO: Support ignoring commits from repo you forked from
# TODO: Accept options in URL
# TODO: Fork and run in background
# TODO: Read options from a file
# TODO: Better error handling; try really hard not to die
#

use HTTP::Daemon;
use HTTP::Request;
use HTTP::Status;
use HTTP::Response;
use LWP::UserAgent;
use IPC::Open3;
use JSON;
use Cwd 'abs_path';
use File::Basename;

use strict;

#
# Settable options
#

# Path to gitmail - defaults to same directory as gmaild lives in
my $GITMAIL = dirname(abs_path($0)) . "/gitmail";

# Port to run on - made up crap
my $PORT = 4577;

# Token to use when calling gitmail API - should belong to an administrator
my $TOKEN = "";

# URL used to make gitlab API calls
>>>>>>> 344221c... Clean up and document options
my $BASEURL = "http://git.flux.utah.edu/";

# Path where gitlab repos live in the FS - doesn't seem available through
# the gitlab API
my $BASEPATH = "/home/git/repositories";

# Unless specified, send mail to this email address on all commits
my $DEFAULT_ARCHIVEMAIL = 'ricci@cs.utah.edu';

#
# End settable options
#

#
# Command line options
# TODO: actually accept on command line
#
my $verbose = 0;

sub run_gitmail($);
sub format_options(@);
sub call_gitlab_api($);

#
# Open up a new socket - runs only on localhost, this thing is not nearly
# secure enough to be open to the world
#
my $listen_socket = HTTP::Daemon->new(LocalAddr => 'localhost',
                                      LocalPort => $PORT) || die;
print "gitmaild running at: ", $listen_socket->url, "\n";

#
# Main loop - pretty simple!
#
while (my $connection = $listen_socket->accept()) {

    while (my $request = $connection->get_request()) {
        if ($verbose) {
            print $request->as_string();
            print "="x80 . "\n";
        }
        # Fork off child
        run_gitmail(decode_json($request->content()));
    }

    # Both are necessary to make sure the connection is really closed
    $connection->close();
    undef($connection);

}

sub run_gitmail($) {
    my ($data) = @_;

    if ($verbose) {
        print "Running gitmail\n";
    }

    # Make it look like it got called as a regular post-recieve hook
    my $refline = $data->{"before"} . " " . $data->{"after"} . " " .
        $data->{"ref"};
    if ($verbose) {
        print $refline . "\n";
    }

    my $userinfo = call_gitlab_api("/users/" . $data->{"user_id"});

    #
    # NB: This depends on the Utah patch to gitlab that adds the project ID
    # to the data in the hook
    #
    my $repoinfo = call_gitlab_api("/projects/" . $data->{"repository"}{"project_id"});

    #
    # Change to the directory where the repo lives - this is the simplest way
    # to make all tools happy
    #
    my $repodir = $BASEPATH . "/" . $repoinfo->{"path_with_namespace"} . ".git";
    chdir $repodir;

    my %options;

    $options{'archivemail'} = $DEFAULT_ARCHIVEMAIL;
    $options{'mailfrom'} = $userinfo->{name} . " <" . $userinfo->{email} . ">";
    $options{'reponame'} = $repoinfo->{path_with_namespace};
    $options{'sshcloneurl'} = $repoinfo->{ssh_url_to_repo};
    if (exists $repoinfo->{http_url_to_repo}) {
        $options{'rocloneurl'} = $repoinfo->{http_url_to_repo};
    }
    $options{'weburl'} = $repoinfo->{web_url};

    my $optionstr = format_options(%options);

    if ($verbose) {
        print "optionstr is '$optionstr'\n";
    }

    #
    # Run gitmail in test mode for now
    #
    my $pid = open3(\*CHILD_IN, \*CHILD_OUT, \*CHILD_ERR,
                "$GITMAIL $optionstr");

    #
    # Pass along the commit information we were given, in the form expected
    # by a git commit hook
    #
    print CHILD_IN $refline . "\n";
    close CHILD_IN;


    waitpid $pid,0;
    print STDOUT <CHILD_OUT>;
    print STDOUT <CHILD_ERR>;

}

#
# Call the function given in the argument, and put the JSON result into a
# perl hash
#
# TODO: Error checking
sub call_gitlab_api($) {
    my ($call) = @_;
    my $url = $BASEURL . "api/v3" . $call . "?private_token=" . $TOKEN;

    my $request = HTTP::Request->new(GET => $url);
    my $ua = LWP::UserAgent->new;
    my $response = $ua->request($request);
    if ($verbose) {
        print "Response: " . $response->as_string . "\n";
    }
    # Error checking
    return decode_json($response->content);
}

#
# Re-format a hash as a string sutable for passing to gitmail
# TODO: support mutiple options
# TODO: proper command line escaping
#
sub format_options(@) {
    my %opt = @_;
    return join(" ",map { "-o " . $_ . "='$opt{$_}'"} keys %opt);
}
