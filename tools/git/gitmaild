#!/usr/bin/perl -w

#
# gitmaild - simple gitmail wrapper for use with gitlab
# Note: *must* be run on the same host, and have permission to read the
# git repos in gitlab's home
# TODO: Support ignoring commits from repo you forked from
# TODO: Accept options in URL
# TODO: Read options from a file
# TODO: Better error handling; try really hard not to die
#

use HTTP::Daemon;
use HTTP::Request;
use HTTP::Status;
use HTTP::Response;
use LWP::UserAgent;
use IPC::Open3;
use Getopt::Long;
use JSON;
use Cwd 'abs_path';
use File::Basename;
use POSIX "setsid";

use strict;

#
# Settable options
#

# Path to gitmail - defaults to same directory as gmaild lives in
my $GITMAIL = dirname(abs_path($0)) . "/gitmail";

# Port to run on - made up crap
my $PORT = 4577;

# Token to use when calling gitmail API - should belong to an administrator
my $TOKEN = "";

# URL used to make gitlab API calls
>>>>>>> 344221c... Clean up and document options
my $BASEURL = "http://git.flux.utah.edu/";

# Path where gitlab repos live in the FS - doesn't seem available through
# the gitlab API
my $BASEPATH = "/home/git/repositories";

# Unless specified, send mail to this email address on all commits
my $DEFAULT_ARCHIVEMAIL = 'ricci@cs.utah.edu';

#
# End settable options
#

#
# Command line options
# TODO: actually accept on command line
#
my $verbose = 0;
my $debug   = 0;

my $result = GetOptions("v" => \$verbose, "d" => \$debug);

sub run_gitmail($);
sub format_options(@);
sub call_gitlab_api($);

#
# Open up a new socket - runs only on localhost, this thing is not nearly
# secure enough to be open to the world
#
my $listen_socket = HTTP::Daemon->new(LocalAddr => 'localhost',
                                      LocalPort => $PORT) || die;
print "gitmaild running at: ", $listen_socket->url, "\n";

# This causes children to be auto-reaped
$SIG{CHLD}="IGNORE";

# Daemonize
if (!$debug) {
    chdir("/")                      || die "can't chdir to /: $!";
    open(STDIN,  "< /dev/null")     || die "can't read /dev/null: $!";
    open(STDOUT, "> /dev/null")     || die "can't write to /dev/null: $!";
    defined(my $pid = fork())       || die "can't fork: $!";
    exit if $pid;                   # non-zero now means I am the parent
    (setsid() != -1)                || die "Can't start a new session: $!";
    open(STDERR, ">&STDOUT")        || die "can't dup stdout: $!";
}


#
# Main loop - pretty simple!
#
while (my $connection = $listen_socket->accept()) {

    while (my $request = $connection->get_request()) {
        if ($verbose) {
            print $request->as_string();
            print "="x80 . "\n";
        }
        # Fork off child
        if (fork()) {
            # Parent
        } else {
            # Child
            exit run_gitmail(decode_json($request->content()));
        }
    }

    # Both are necessary to make sure the connection is really closed
    $connection->close();
    undef($connection);

}

#
# Actually run gitmail, using the data that we pulled out of the JSON that
# was passed to us
#
sub run_gitmail($) {
    my ($data) = @_;

    if ($verbose) {
        print "Running gitmail\n";
    }

    # TODO: Error handling (or at least reporting)

    #
    # Get information about the user so that we can set, eg., 'from'
    # appropriately
    #
    my $userinfo = call_gitlab_api("/users/" . $data->{"user_id"});

    #
    # Get information about the project, so that we know where the repo lives,
    # etc.
    # NB: This depends on the Utah patch to gitlab that adds the project ID
    # to the data in the hook
    #
    my $repoinfo = call_gitlab_api("/projects/" . $data->{"repository"}{"project_id"});

    #
    # Change to the directory where the repo lives - this is the simplest way
    # to make all tools happy
    #
    my $repodir = $BASEPATH . "/" . $repoinfo->{"path_with_namespace"} . ".git";
    chdir $repodir;

    #
    # Build up options that we'll pass to gitmail
    #
    my %options;

    # Address to always send mail to
    $options{'archivemail'} = $DEFAULT_ARCHIVEMAIL;

    # Who the mail comes from - user doing the push
    $options{'mailfrom'} = $userinfo->{name} . " <" . $userinfo->{email} . ">";

    # Name of the repo
    $options{'reponame'} = $repoinfo->{path_with_namespace};

    # URLs to push/pull from
    $options{'sshcloneurl'} = $repoinfo->{ssh_url_to_repo};
    if (exists $repoinfo->{http_url_to_repo}) {
        $options{'rocloneurl'} = $repoinfo->{http_url_to_repo};
    }

    # gitlab's URL for this project
    $options{'weburl'} = $repoinfo->{web_url};

    # Turn all of this into a string to pass on the command line
    my $optionstr = format_options(%options);
    if ($verbose) {
        print "optionstr is '$optionstr'\n";
    }

    # 
    # Build up a refline that makes it look like gitmail got called
    # as a regular post-recieve hook
    #
    my $refline = $data->{"before"} . " " . $data->{"after"} . " " .
        $data->{"ref"};
    if ($verbose) {
        print $refline . "\n";
    }

    #
    # Actually run gitmail
    #
    my $pid = open3(\*CHILD_IN, \*CHILD_OUT, \*CHILD_ERR,
                "$GITMAIL $optionstr");

    #
    # Pass along the commit information we were given, in the form expected
    # by a git commit hook
    #
    print CHILD_IN $refline . "\n";
    close CHILD_IN;

    #
    # Wait for the child to finish
    #
    waitpid $pid,0;
    print STDOUT <CHILD_OUT>;
    print STDOUT <CHILD_ERR>;

    #
    # Done!
    #
    return 0;

}

#
# Call the function given in the argument, and put the JSON result into a
# perl hash
#
# TODO: Error checking
sub call_gitlab_api($) {
    my ($call) = @_;

    # Hardcode API v3 for now
    my $url = $BASEURL . "api/v3" . $call . "?private_token=" . $TOKEN;

    # Super simple, make the call
    my $request = HTTP::Request->new(GET => $url);
    my $ua = LWP::UserAgent->new;
    my $response = $ua->request($request);
    if ($verbose) {
        print "Response: " . $response->as_string . "\n";
    }

    # TODO: Error checking
    return decode_json($response->content);
}

#
# Re-format a hash as a string sutable for passing to gitmail
# TODO: support mutiple options
# TODO: proper command line escaping
#
sub format_options(@) {
    my %opt = @_;
    return join(" ",map { "-o " . $_ . "='$opt{$_}'"} keys %opt);
}
